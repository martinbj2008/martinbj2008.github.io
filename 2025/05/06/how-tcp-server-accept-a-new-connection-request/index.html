<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>tcp三次握手 --- 逐渐消失的tcp半链接队列 | Kernel Study Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概要：十年演进对比历史实现(v4.3)网上大部分文档这部分内容讲的比较多，简单来说，可以把半链接队列的逻辑概括如下:  收到syn报文，查找listen socket。 创建一个半链接socket(req socket)，并放入listen socket的半链接队列里，发送syn+ack报文 收到client回复的ack报文，查找到对应的半链接socket(req socket) 基于半链接s">
<meta property="og:type" content="article">
<meta property="og:title" content="tcp三次握手 --- 逐渐消失的tcp半链接队列">
<meta property="og:url" content="https://martinbj2008.github.io/2025/05/06/how-tcp-server-accept-a-new-connection-request/index.html">
<meta property="og:site_name" content="Kernel Study Notes">
<meta property="og:description" content="概要：十年演进对比历史实现(v4.3)网上大部分文档这部分内容讲的比较多，简单来说，可以把半链接队列的逻辑概括如下:  收到syn报文，查找listen socket。 创建一个半链接socket(req socket)，并放入listen socket的半链接队列里，发送syn+ack报文 收到client回复的ack报文，查找到对应的半链接socket(req socket) 基于半链接s">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://martinbj2008.github.io/images/sock/tcp_handshake_summary.png">
<meta property="og:image" content="https://martinbj2008.github.io/images/sock/tcp_lockless_git_repo.png">
<meta property="og:image" content="https://martinbj2008.github.io/images/sock/tcp_ehash_hlist.png">
<meta property="og:image" content="https://martinbj2008.github.io/images/sock/struct_tcp_sock.png">
<meta property="og:image" content="https://martinbj2008.github.io/images/sock/russian.jpg">
<meta property="og:image" content="https://martinbj2008.github.io/images/sock/struct_tcp_request_sock.png">
<meta property="article:published_time" content="2025-05-06T14:29:11.000Z">
<meta property="article:modified_time" content="2025-05-28T12:13:09.570Z">
<meta property="article:author" content="Martinbj2008">
<meta property="article:tag" content="tcp">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="IPv4">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://martinbj2008.github.io/images/sock/tcp_handshake_summary.png">
  
    <link rel="alternate" href="/atom.xml" title="Kernel Study Notes" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kernel Study Notes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://martinbj2008.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-how-tcp-server-accept-a-new-connection-request" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/05/06/how-tcp-server-accept-a-new-connection-request/" class="article-date">
  <time class="dt-published" datetime="2025-05-06T14:29:11.000Z" itemprop="datePublished">2025-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/socket/">socket</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      tcp三次握手 --- 逐渐消失的tcp半链接队列
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- toc -->

<h2 id="概要：十年演进对比"><a href="#概要：十年演进对比" class="headerlink" title="概要：十年演进对比"></a>概要：十年演进对比</h2><h3 id="历史实现-v4-3"><a href="#历史实现-v4-3" class="headerlink" title="历史实现(v4.3)"></a>历史实现(v4.3)</h3><p>网上大部分文档这部分内容讲的比较多，简单来说，可以把半链接队列的逻辑概括如下:</p>
<ul>
<li>收到syn报文，查找listen socket。</li>
<li>创建一个半链接socket(req socket)，并放入listen socket的半链接队列里，发送syn+ack报文</li>
<li>收到client回复的ack报文，查找到对应的半链接socket(req socket)</li>
<li>基于半链接socket和ack报文创建child socket</li>
<li>把child socket(req)加入到accept队列中，等待accept系统调用&#x2F;激活</li>
</ul>
<h3 id="当前实现-v6-14"><a href="#当前实现-v6-14" class="headerlink" title="当前实现(v6.14)"></a>当前实现(v6.14)</h3><p>在v6.14内核里，三次握手的处理流程如下：</p>
<ul>
<li>step1：收到一个syn请求报文：查找到对应的listen socket</li>
<li>step2：创建一个半链接socket(req socket)，记录 syn 请求的一些字段信息，如seq, mss等。</li>
<li>step3：构造并发送syn+ack报文</li>
<li>step4:  把半链接socket(req socket)放入全局(netns)的ehash链表中，并统计半链接socket个数。通常说的半链接队列长度。<br> + 全局：确切说是，当前netns(net namesapce)。一般默认是指当前物理机的内核协议栈。当有 docker实例（启用网络隔离）时候，全局则是指当前 docker 实例的内核协议栈。docker如何使用netsns隔离，不展开。为了理解方便，这里我们以没有docker 隔离的场景为例。<br> + ehash链表：一个hash 链表，存放有全部establish状态的socket，当然tw状态的也在这个链表里。关联度不高，不展开。<br> <em><strong>不同点 ：使用全局ehash链表，而不是 listen socket的半链接队列</strong></em></li>
<li>step5：收到client回复的ack报文，查找到对应的半链接socket(req socket)</li>
<li>step6：基于半链接socket 和ack报文创建child socket</li>
<li>step7：把新创建的child socket 插入到 ehash链表中。同时把req socket从链上摘掉。</li>
<li>step8：把req socket加入到listen socket的accept队列中，同时让req下的关联<code>socket</code>指针指向child。</li>
<li>step9： 发送listen socket的data_ready消息给应用程序， 等待listen socket上的accept系统调用&#x2F;激活。</li>
<li>step10： accept系统调用把req socket从accept队列上拆除。同时，封装child socket，给用户返回其对应的fd.</li>
</ul>
<p> <img src="/images/sock/tcp_handshake_summary.png" alt="tcp三次握手概要图"></p>
<h3 id="差异点"><a href="#差异点" class="headerlink" title="差异点"></a>差异点</h3><ul>
<li>使用全局ehash 链表而不是listen socket 下的半链接队列, 来存放半链接(req) socket。<br>  队列只是一个习惯性的叫法，严格意义上说不合适。很早(20+年)之前，内核就已经使用hash链接替换队列存放半链接socket了。</li>
<li>长度检查：半链接个数(队列长度)和accept队列长度的检查</li>
<li>ack报文处理逻辑：查找半链接socket，减少锁listen socket的时长。</li>
</ul>
<span id="more"></span>

<h3 id="对应内核patch"><a href="#对应内核patch" class="headerlink" title="对应内核patch"></a>对应内核patch</h3><p>2015年（没错十年前）内核加入了组性能优化的patch，将半链接socket(req socket)放到了一个全局的hash链表里。之前半链接socket是存放到对应listen socket下的半链接hash链表里(syn_table)。<br>这个系列的patch的主要目的是为了优化性能，但在patch里也改变了长度判断。</p>
<p>其中 在patch里明确提到半链接socket的变化<em><strong>tcp&#x2F;dccp: install syn_recv requests into ehash table</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In this patch, we insert request sockets into TCP/DCCP regular ehash table (where ESTABLISHED and TIMEWAIT sockets are) instead of using the per listener hash table.</span><br><span class="line">ACK packets find SYN_RECV pseudo sockets without having to find and lock the listener. In nominal conditions, this halves pressure on listener lock. </span><br><span class="line">Note that this will allow for SO_REUSEPORT refinements, so that we can select a listener using cpu/numa affinities instead of the prior &#x27;consistent hash&#x27;,</span><br><span class="line">since only SYN packets will apply this selection logic. We will shrink listen_sock in the following patch to ease code review.</span><br></pre></td></tr></table></figure>

<p>详见链接<br><a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?h=v6.15-rc4&ofs=799322">内核patch：tcp lockless</a><br><img src="/images/sock/tcp_lockless_git_repo.png" alt="tcp lockless patch 截图"></p>
<h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>内核实现里，相关数据结构和函数总结如下<br><em><strong>数据结构：</strong></em></p>
<ul>
<li>一个 hash 链表： 全局(per ns)ehash 链表</li>
<li>三个 socket：半链接 socket(req),  child socket，listen socket。后两个都是tcp sock</li>
<li>每个listensocket 下：<ul>
<li>一个 accept 队列</li>
<li>一个半链接socket 个数统计</li>
</ul>
</li>
</ul>
<p><em><strong>关键函数：</strong></em></p>
<ul>
<li>tcp_v4_rcv&#x2F;tcp_v4_do_rcv:  协议栈里 tcp 报文入口函数</li>
<li>tcp_connet_requst：SYN 报文处理核心函数</li>
<li>tcp_v4_syn_recv_sock:  ACK报文处理核心函数</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="ehash链表"><a href="#ehash链表" class="headerlink" title="ehash链表"></a>ehash链表</h4><p>一个全局的 hash 链表，存放有全部establish状态的socket，当然tw状态的也在这个链表里。关联度不高，不展开。<br><img src="/images/sock/tcp_ehash_hlist.png" alt="tcp ehash 链表"></p>
<h4 id="tcp-sock"><a href="#tcp-sock" class="headerlink" title="tcp_sock"></a>tcp_sock</h4><p>tcp socket 可以通过两种方式创建，</p>
<ul>
<li>系统调用：<code>socket(AF_INET, SOCK_STREAM, 0)</code></li>
<li>系统调用accept：<br>系统调用返回给用户空间的fd是一个整数。每个fd在内核都对应一个结构体<code>struct tcp_sock</code>， 我们称之为 tcp socket。从 fd 到<code>tcp_sock</code>的映射比较繁琐，这里不展开介绍。</li>
</ul>
<h5 id="tcp-sock-结构体定义"><a href="#tcp-sock-结构体定义" class="headerlink" title="tcp_sock 结构体定义"></a>tcp_sock 结构体定义</h5><p>具体内容如下图所示：<br><img src="/images/sock/struct_tcp_sock.png" alt="tcp_sock"></p>
<h5 id="tcp-sock的套娃式变形"><a href="#tcp-sock的套娃式变形" class="headerlink" title="tcp_sock的套娃式变形"></a>tcp_sock的套娃式变形</h5><p><img src="/images/sock/russian.jpg" alt="俄罗斯套娃"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">194 struct tcp_sock &#123;</span><br><span class="line">...</span><br><span class="line">200         /* inet_connection_sock has to be the first member of tcp_sock */</span><br><span class="line">201         struct inet_connection_sock     inet_conn;</span><br><span class="line">202</span><br><span class="line">203         /* TX read-mostly hotpath cache lines */</span><br><span class="line">204         __cacheline_group_begin(tcp_sock_read_tx);</span><br></pre></td></tr></table></figure>
<p>在内核协议栈这部分代码的各类socket结构体定义里，套娃模式被广泛使用。以<code>tcp_sock</code>为例， 大部分的tcp处理函数，传递参数时候并不是使用的<code>tcp_sock</code>这个类型，而是使用起下面的子类型，<code>struct sock *</code>等. 比如 tcp 协议处理的主函数 <code>tcp_v4_do_rcv</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)</span><br></pre></td></tr></table></figure>
<p>  当需要读写<code>tcp_sock</code>下数据时候，才会通过宏换到<code>tcp_sock</code>.</p>
<ul>
<li>tcp_sk(ptr):</li>
<li>inet_csk(ptr): 借助<code>icsk_inet.sk</code>，<code>sock</code> –&gt; <code>inet_connection_sock</code>.  </li>
<li>req_to_sk(req)：</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define tcp_sk(ptr) container_of_const(ptr, struct tcp_sock, inet_conn.icsk_inet.sk)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="半链接-socket-req-socket"><a href="#半链接-socket-req-socket" class="headerlink" title="半链接 socket(req socket)"></a>半链接 socket(req socket)</h4><p><img src="/images/sock/struct_tcp_request_sock.png" alt="tcp半链接socket"></p>
<h3 id="SYN报文的处理流程"><a href="#SYN报文的处理流程" class="headerlink" title="SYN报文的处理流程"></a>SYN报文的处理流程</h3><h4 id="tcp-v4-rcv调用栈"><a href="#tcp-v4-rcv调用栈" class="headerlink" title="tcp_v4_rcv调用栈"></a>tcp_v4_rcv调用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tcp_v4_rcv(struct sk_buff *skb)</span><br><span class="line"> |--&gt; sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest); </span><br><span class="line"> |--&gt; tcp_v4_do_rcv(sk, skb);</span><br><span class="line">       |--&gt; struct sock *nsk = tcp_v4_hnd_req(sk, skb)</span><br><span class="line">       |--&gt; tcp_rcv_state_process</span><br><span class="line">             |--&gt; if (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0) 相当 tcp_v4_conn_request</span><br></pre></td></tr></table></figure>
<h4 id="tcp-v4-conn-request调用栈"><a href="#tcp-v4-conn-request调用栈" class="headerlink" title="tcp_v4_conn_request调用栈"></a>tcp_v4_conn_request调用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tcp_v4_conn_request</span><br><span class="line"> |--&gt; tcp_conn_request(&amp;tcp_request_sock_ops, &amp;tcp_request_sock_ipv4_ops, sk, skb);</span><br><span class="line">       |--&gt; tcp_v4_conn_request(&amp;tcp_request_sock_ops, &amp;tcp_request_sock_ipv4_ops, sk, skb);</span><br><span class="line">             |--&gt; sk_acceptq_is_full(sk)</span><br><span class="line">             |--&gt; req = inet_reqsk_alloc(rsk_ops, sk, !want_cookie);</span><br><span class="line">                   |--&gt; struct request_sock *req = reqsk_alloc(ops, sk_listener, attach_listener);</span><br><span class="line">                   |--&gt; ireq-&gt;ireq_state = TCP_NEW_SYN_RECV; //ireq = inet_rsk(req); #define ireq_state req.__req_common.skc_state</span><br><span class="line">             |--&gt; tcp_openreq_init(req, &amp;tmp_opt, skb);</span><br><span class="line">             |--&gt; inet_csk_reqsk_queue_hash_add(sk, req, req-&gt;timeout)</span><br><span class="line">                  |--&gt; reqsk_queue_hash_req(req, timeout)</span><br><span class="line">                        |--&gt; inet_ehash_insert(req_to_sk(req), NULL, &amp;found_dup_sk) //将 req sock放到 establish hash链表里</span><br><span class="line">                  |--&gt; inet_csk_reqsk_queue_added</span><br><span class="line">                        |--&gt; reqsk_queue_added(&amp;inet_csk(sk)-&gt;icsk_accept_queue); //半链接队列，真实名字叫 accept。功能也只有计数能力了，没有队列了。</span><br><span class="line">                              |--&gt; atomic_inc(&amp;queue-&gt;qlen);</span><br><span class="line">             |--&gt; af_ops-&gt;send_synack  //发送synack报文</span><br></pre></td></tr></table></figure>

<h4 id="tcp的入口函数-tcp-v4-rcv"><a href="#tcp的入口函数-tcp-v4-rcv" class="headerlink" title="tcp的入口函数: tcp_v4_rcv"></a>tcp的入口函数: tcp_v4_rcv</h4><p><code>tcp_v4_rcv</code>是协议栈的处理tcp协议(ipv4)的入口函数。类似，ipv6的tcp处理函数<code>tcp_v6_rcv</code>。所有的发往本地的ipv4+tcp报文，在IP协议处理完成后，都会走到<code>tcp_v4_rcv</code> 这个入口函数里。<br>这个函数代码内容比较多，三次握手逻辑，重点关注step1 和 step3:</p>
<ul>
<li>step1：根据syn报文五元组，查找到对应的socket，初次 syn 报文应该是listen socket。简单起见，不考虑SYN<br>报文重传。<em><strong>与 ACK 报文不一样</strong></em></li>
<li>step2：基本检查：按流程协议栈首先做一些基本的校验和检查，比如，报文长度，tcp checksum等。不展开跳过。</li>
<li>step3：调用<code>tcp_v4_do_rcv</code> 处理 syn 报文。</li>
</ul>
<p>几点解释：</p>
<ul>
<li>根据 tcp 报文里的五元组信息的不同组合查找对应的 sk，如果找不到 sk，则丢弃报文。</li>
<li>*** sk_state***  socket的状态。根据 sk 的状态<code>sk_state</code>又区分为几个场景，<ul>
<li>tw(<code>TCP_TIME_WAIT</code>) socket : 与主题无关，略过。</li>
<li>半链接(<code>TCP_NEW_SYN_RECV</code>) socket : 三次握手时候ACK报文场景， 后面展开。 </li>
<li>其他(如 listen， establish）：做一些通用和统计后，调用<code>tcp_v4_do_rcv</code> 统一处理。</li>
</ul>
</li>
</ul>
<p><em><strong>备注：</strong></em></p>
<ul>
<li><p>如果socket 被用户空间调用临时锁住，会放到待处理队列backlog里，等释放sk锁后再处理。</p>
</li>
<li><p>socket 查找： 单独展开讲述。</p>
<ul>
<li>按五元组查找：establish、tw、半链接</li>
<li>listensocket 的查找：对应 listen 调用时候的两种使用方式。<ul>
<li>按 ip&#x2F;port：指定 IP+port。</li>
<li>按port： 不指定 IP(参数里使用 any 或0），仅指定port</li>
</ul>
</li>
</ul>
<p>  【备注 1】通用检查包括：<br>      + xfrm4_policy_check：vpn相关的场景。当前 socket有ipsec规则和sa配置的场景，或者支持xfrm 卸载场景等。<br>      + tcp_inbound_hash：MD5类检查， 具体没展开看。<br>      + tcp_filter: 运行附着在 socket 上的 ebfp程序，做 socket 过滤。<br>      + tcp_segs_in：统计socket 收到的 tso 报文个数。</p>
</li>
</ul>
<h4 id="tcp-v4-do-rcv"><a href="#tcp-v4-do-rcv" class="headerlink" title="tcp_v4_do_rcv"></a>tcp_v4_do_rcv</h4><p>先处理<code>TCP_ESTABLISHED</code>和<code>TCP_LISTEN</code>两类状态下的 tcp socket， 其他状态的 socket会被<code>tcp_rcv_state_process</code>处理。</p>
<ul>
<li>TCP_ESTABLISHED：tcp_rcv_established处理数据报文，超时、乱序等。不展开</li>
<li>TCP_LISTEN： <code>tcp_v4_cookie_check</code> 和<code>tcp_child_process</code>。对应场景是，启用了 cookie下的 ack报文，这时候没有半链接 socket，所以会走到listen socket场景下处理。并产生一个 child socket。关联低，不展开。 我们这个场景下，SYN 报文不会进入这个逻辑。这里代码比较绕，<br><em><strong>小心掉坑</strong></em>。 cookie检查只针对非 SYN 报文，所以 SYN 报文在<code>tcp_v4_cookie_check</code>返回的还是原来的 listen socket。只有返回的 socket 不是 listen socket 的 场景才会调用<code>tcp_child_process</code>。</li>
</ul>
<h5 id="tcp-rcv-state-process"><a href="#tcp-rcv-state-process" class="headerlink" title="tcp_rcv_state_process"></a>tcp_rcv_state_process</h5><p>这个函数，根据报文对应socket 的状态走不同分支。场景非常多，不逐一展开。 SYN 报文对应listen socket，因此走TCP_LISTEN分支。调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb);</span><br></pre></td></tr></table></figure>
<p>这里等同于调用<code>tcp_v4_conn_request(sk, skb)</code>。</p>
<h4 id="核心函数-tcp-v4-conn-request-tcp-conn-request"><a href="#核心函数-tcp-v4-conn-request-tcp-conn-request" class="headerlink" title="核心函数: tcp_v4_conn_request &amp; tcp_conn_request"></a>核心函数: <code>tcp_v4_conn_request</code> &amp; <code>tcp_conn_request</code></h4><p>tcp_v4_conn_request<code>&amp;</code>tcp_conn_request&#96; 是SYN报文处理的核心， 我们按代码顺序讲解</p>
<ul>
<li>step1：半链接和accpet 队列长度检查，这部分确保队列不溢出。 后面展开讲。</li>
<li>step2：创建一个类型为<code>struct request_sock</code>的半链接 socket <code>req</code>, 并设置状态为***<code>TCP_NEW_SYN_RECV</code>***</li>
<li>step3：初始化半链接 socket <code>req</code>。 包括 SYN 报文里携带的信息，如seq(client侧)、tcp mss、时间戳、win scale等。</li>
<li>step4： 初始化<code>req</code>的路由。根据五元组、网口等信息，查找路由并缓存，为后续SYN_ACK准备。</li>
<li>step5：<code>req</code>的其他初始化。如时间戳、seq、tos、window大小、record_syn等。关联度低，跳过。</li>
<li>step6：*<em><strong>【核心】</strong></em> 把<code>req</code>插入到 ehash 队列里，并且把统计个数+1。对应实现函数<code>inet_csk_reqsk_queue_hash_add</code></li>
<li>step7： 发送 SYN_ACK报文。<code>af_ops-&gt;send_synack</code>, 关联度低，跳过。</li>
</ul>
<p><em><strong>备注</strong></em></p>
<ul>
<li>fastopen场景：代码里会考虑对 fastopen 场景的支持，因为关联度低，简单起见，解释代码时跳过这部分逻辑。</li>
</ul>
<h4 id="inet-csk-reqsk-queue-hash-add"><a href="#inet-csk-reqsk-queue-hash-add" class="headerlink" title="inet_csk_reqsk_queue_hash_add"></a><code>inet_csk_reqsk_queue_hash_add</code></h4><p>两个核心功能</p>
<ul>
<li><code>reqsk_queue_hash_req</code>: 插入 ehash 队列<ul>
<li><code>inet_ehash_insert</code> </li>
<li>更新半链接的定时器及引用计数</li>
</ul>
</li>
<li><code>inet_csk_reqsk_queue_added</code>: 统计数增加。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|--&gt; reqsk_queue_added(&amp;inet_csk(sk)-&gt;icsk_accept_queue); </span><br><span class="line">      |--&gt; atomic_inc(&amp;queue-&gt;qlen);</span><br></pre></td></tr></table></figure>
<em><strong>备注</strong></em> </li>
<li><code>reqsk_queue_added</code>: 函数名字还保留半链接队列，真正操作的其实是accept队列结构体里的字段。功能也保留统计计数的能力，没有队列了。</li>
<li>此处要回顾下accept队列在 listensocket 中的位置。</li>
</ul>
<h3 id="ACK握手报文的处理流程"><a href="#ACK握手报文的处理流程" class="headerlink" title="ACK握手报文的处理流程"></a>ACK握手报文的处理流程</h3><h4 id="tcp-v4-rcv调用栈-1"><a href="#tcp-v4-rcv调用栈-1" class="headerlink" title="tcp_v4_rcv调用栈"></a><code>tcp_v4_rcv</code>调用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tcp_v4_rcv(struct sk_buff *skb)</span><br><span class="line"> |--&gt; sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line"> |--&gt; if (sk-&gt;sk_state == TCP_NEW_SYN_RECV) //SYN报文创建req时设置的</span><br><span class="line">       |--&gt; nsk = tcp_check_req(sk, skb, req, false, &amp;req_stolen);  //前置条件：通过tcp_filter</span><br><span class="line">             |--&gt; child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, NULL); //tcpv4对应函数tcp_v4_syn_recv_sock</span><br><span class="line">             |--&gt; inet_csk_complete_hashdance(sk, child, req, own_req);</span><br><span class="line">       |--&gt; tcp_child_process(sk, nsk, skb)</span><br><span class="line">             |--&gt; tcp_rcv_state_process(child, skb, tcp_hdr(skb),</span><br><span class="line">                   |--&gt; tcp_set_state(sk, TCP_ESTABLISHED); </span><br><span class="line">             |--&gt; parent-&gt;sk_data_ready(parent);//唤醒accept等待进程</span><br></pre></td></tr></table></figure>
<h4 id="tcp-v4-syn-recv-sock调用栈"><a href="#tcp-v4-syn-recv-sock调用栈" class="headerlink" title="tcp_v4_syn_recv_sock调用栈"></a><code>tcp_v4_syn_recv_sock</code>调用栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tcp_v4_syn_recv_sock</span><br><span class="line">  |--&gt; sk_acceptq_is_full //检查accept队列长度，如果满了，则丢弃。</span><br><span class="line">        |--&gt; sk-&gt;sk_ack_backlog &gt; sk-&gt;sk_max_ack_backlog ;</span><br><span class="line">  |--&gt; newsk = tcp_create_openreq_child(sk, req, skb); //newsk是新创建的child socket。</span><br><span class="line">        |--&gt; newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC); //复制一个socket并加锁</span><br><span class="line">        |--&gt; __TCP_INC_STATS(sock_net(sk), TCP_MIB_PASSIVEOPENS); </span><br><span class="line">  |--&gt; __inet_inherit_port</span><br><span class="line">  |--&gt; inet_ehash_nolisten(newsk, req_to_sk(req_unhash), &amp;found_dup_sk)</span><br><span class="line">        |--&gt; inet_ehash_insert(sk, osk, found_dup_sk);//在ehash表里，插入新的child socket， 并删去原有req sock</span><br><span class="line">              |--&gt; sk_nulls_del_node_init_rcu(osk);  //将req从ehash链里摘除</span><br><span class="line">              |--&gt; __sk_nulls_add_node_rcu(sk, list); //将child socket插入到ehash链里</span><br></pre></td></tr></table></figure>

<h4 id="函数tcp-v4-rcv处理握手ACK"><a href="#函数tcp-v4-rcv处理握手ACK" class="headerlink" title="函数tcp_v4_rcv处理握手ACK"></a>函数tcp_v4_rcv处理握手ACK</h4><p>与 SYN 报文一样，ACK报文进入首先进入tcp协议栈入口函数<code>tcp_v4_rcv</code>。针对 ack 报文的主要处理步骤</p>
<ul>
<li>step1：根据ACK 报文五元组，查找到ehash 链表里的半链接 socket(req socket）。<br>  这部分跟之前逻辑变化比较大。4.3 以前的内核，比如3.10，内核协议栈根据ACK 报文先找到 listen socket，然后在listen socket 下的半链接队列里。<br>  而现在代码，req socket 被放到 ehash 链表中，所以直接查找到 req socket，而不需要像以前一样需要对 listen socket 进行加锁等操作。<br>  为了跟以前 req socket 的状态<code>TCP_SYN_RECV</code>进行区别，协议栈还特意为ehash里的req socket增加了一个新的 tcp状态编码<code>TCP_NEW_SYN_RECV</code>.</li>
<li>step2:  进入<code>TCP_NEW_SYN_RECV</code>处理分支半链接 socket。</li>
<li>step3： 调用tcp_check_req，创建一个child socket。把child socket插入到ehash链表，把req从 ehash 链表删除，放入accept 队列。后面在函数<code>tcp_v4_syn_recv_sock</code>里详述。</li>
<li>step4：处理 child socket 状态转换，并激活在 listen socket 等待队列上等待的 accept调用进程。</li>
</ul>
<h4 id="核心函数tcp-v4-syn-recv-sock"><a href="#核心函数tcp-v4-syn-recv-sock" class="headerlink" title="核心函数tcp_v4_syn_recv_sock"></a>核心函数<code>tcp_v4_syn_recv_sock</code></h4><p>握手ACK报文的核心处理函数是<code>tcp_v4_syn_recv_sock</code>，其主要处理步骤有三步：</p>
<ul>
<li>accept 队列检查it：确保队列没有溢出。具体判断条件，后续专门展开解释。</li>
<li>创建 child socket：</li>
<li>调整 req、child socket：<br>  在ehash表里，插入新的child socket， 并删去原有req socket。<br>  通过 req socket 下的 socket 指针指向 child，确保将来 accept时候，根据req 找到 child。<br>  把 req socket 挂载到 accept 队列尾部，等待 accept 系统调用。</li>
</ul>
<p>至此，其实针对 tcp 报文来说，child socket 已经建立完成了，并处于established状态，<br>所以即使没有accept，发往child socket的数据也不会丢失。</p>
<p>放在 accept 队列里的其实是半链接 req socket。</p>
<h4 id="查找skb的socket：-inet-lookup-skb"><a href="#查找skb的socket：-inet-lookup-skb" class="headerlink" title="查找skb的socket：__inet_lookup_skb"></a>查找skb的socket：__inet_lookup_skb</h4><p>当 tcp 协议栈收到一个报文时候，首先就要做的一件事就就是查找这个 skb 报文对应的 socket。<br>这个功能是在<code>__inet_lookup_skb</code>里实现的。这个查找是有两类查找组成。</p>
<ul>
<li>step1： 在ehash链表里查。查找的KEY是五元组。<br>  尽管这个名字叫 ehash，但是存放的 socket 不仅有established状态的，<br>  还有 Timewait状态的socket,<br>  还有我们刚讨论的<code>TCP_NEW_SYN_RECV</code>状态的半链接req socket。</li>
<li>step2： 如果没有ehash 里没有找到，继续在listen socket 里查找。这里我们回忆下bind调用时的两种bind形式<ul>
<li>绑定到指定IP+port：查找时候KEY是IP+PORT。</li>
<li>绑定到指定port, IP任意：查找时候KEY是PORT。IP是0.</li>
</ul>
</li>
</ul>
<p>解释：<br>inet_ehash_insert 对 req 和 child 的区别， 一个只增加， 一个要删除旧的再加新的</p>
<h3 id="accpet队列和半链接个数溢出的新标准"><a href="#accpet队列和半链接个数溢出的新标准" class="headerlink" title="accpet队列和半链接个数溢出的新标准"></a>accpet队列和半链接个数溢出的新标准</h3><p> <a href="/2025/04/03/2025-04-03-req-queue-length-check/">tcp 队列长度检查</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://martinbj2008.github.io/2025/05/06/how-tcp-server-accept-a-new-connection-request/" data-id="cmb7wpkr3002d1qoa73ub2ivn" data-title="tcp三次握手 --- 逐渐消失的tcp半链接队列" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IPv4/" rel="tag">IPv4</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/05/07/tcp-paws-check/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          PAWS 在tcp协议栈中的实现
        
      </div>
    </a>
  
  
    <a href="/2025/05/05/tcp-req-queue-length-check/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">创建req scoket时的三个长度检查</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IPv6/">IPv6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bpf/">bpf</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/debug/">debug</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gcc/">gcc</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/irq/">irq</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memory/">memory</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/neighbour/">neighbour</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/netdev/">netdev</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/netlink/">netlink</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/others/">others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/route/">route</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sched/">sched</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/xfrm/">xfrm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPv4/" rel="tag">IPv4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPv6/" rel="tag">IPv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TODO/" rel="tag">TODO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/address/" rel="tag">address</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bh/" rel="tag">bh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bpf/" rel="tag">bpf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/checksum/" rel="tag">checksum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/" rel="tag">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll/" rel="tag">epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gcc/" rel="tag">gcc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ipv6/" rel="tag">ipv6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/irq/" rel="tag">irq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory/" rel="tag">memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/namespace/" rel="tag">namespace</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/neighbour/" rel="tag">neighbour</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netdev/" rel="tag">netdev</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netlink/" rel="tag">netlink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/" rel="tag">others</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ovs/" rel="tag">ovs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/route/" rel="tag">route</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sched/" rel="tag">sched</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket-tcp/" rel="tag">socket, tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/" rel="tag">tcp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcpdump/" rel="tag">tcpdump</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xdp/" rel="tag">xdp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xfrm/" rel="tag">xfrm</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IPv4/" style="font-size: 20px;">IPv4</a> <a href="/tags/IPv6/" style="font-size: 10.83px;">IPv6</a> <a href="/tags/TODO/" style="font-size: 10px;">TODO</a> <a href="/tags/address/" style="font-size: 14.17px;">address</a> <a href="/tags/bh/" style="font-size: 14.17px;">bh</a> <a href="/tags/bpf/" style="font-size: 16.67px;">bpf</a> <a href="/tags/checksum/" style="font-size: 10.83px;">checksum</a> <a href="/tags/debug/" style="font-size: 11.67px;">debug</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/gcc/" style="font-size: 14.17px;">gcc</a> <a href="/tags/git/" style="font-size: 12.5px;">git</a> <a href="/tags/ipv6/" style="font-size: 10.83px;">ipv6</a> <a href="/tags/irq/" style="font-size: 17.5px;">irq</a> <a href="/tags/memory/" style="font-size: 13.33px;">memory</a> <a href="/tags/namespace/" style="font-size: 10px;">namespace</a> <a href="/tags/neighbour/" style="font-size: 10px;">neighbour</a> <a href="/tags/netdev/" style="font-size: 18.33px;">netdev</a> <a href="/tags/netlink/" style="font-size: 13.33px;">netlink</a> <a href="/tags/others/" style="font-size: 10.83px;">others</a> <a href="/tags/ovs/" style="font-size: 10px;">ovs</a> <a href="/tags/route/" style="font-size: 18.33px;">route</a> <a href="/tags/sched/" style="font-size: 14.17px;">sched</a> <a href="/tags/socket/" style="font-size: 19.17px;">socket</a> <a href="/tags/socket-tcp/" style="font-size: 10px;">socket, tcp</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/tcpdump/" style="font-size: 15.83px;">tcpdump</a> <a href="/tags/vim/" style="font-size: 11.67px;">vim</a> <a href="/tags/xdp/" style="font-size: 10.83px;">xdp</a> <a href="/tags/xfrm/" style="font-size: 15px;">xfrm</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">June 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/10/">October 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/01/">January 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/06/">June 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2009/05/">May 2009</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/12/">December 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/11/">November 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/10/">October 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/09/">September 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/08/">August 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/07/">July 2007</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2007/06/">June 2007</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/05/07/tcp-paws-check/">PAWS 在tcp协议栈中的实现</a>
          </li>
        
          <li>
            <a href="/2025/05/06/how-tcp-server-accept-a-new-connection-request/">tcp三次握手 --- 逐渐消失的tcp半链接队列</a>
          </li>
        
          <li>
            <a href="/2025/05/05/tcp-req-queue-length-check/">创建req scoket时的三个长度检查</a>
          </li>
        
          <li>
            <a href="/2025/05/03/netdev-state-flags-part2/">网口状态标志位解析part2: 内核如何维护网卡carrier的状态</a>
          </li>
        
          <li>
            <a href="/2025/05/01/netdev-state-flags-part1/">网口状态标志位详解(Part 1/2)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Martinbj2008<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>