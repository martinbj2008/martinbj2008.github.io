
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Netdevice Watchdog Cause Tx Queue Schedule - My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="test case For ixgbe nic, we want to assign a tx hardware qeueue to each cpu,
and the tx softirq should use the corresponding hardware queue. each &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://martinbj2008.github.io/blog/2014/09/17/netdevice-watchdog-cause-tx-queue-schedule/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->
<!-- link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" -->

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="martinbj2008.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Netdevice Watchdog Cause Tx Queue Schedule</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-17T15:38:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>3:38 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3>test case</h3>

<p>For ixgbe nic, we want to assign a tx hardware qeueue to each cpu,
and the tx softirq should use the corresponding hardware queue.</p>

<p>each packet will select a softqueue in <code>dev_queue_xmit</code>,
we rewrite ixgbe driver <code>ndo_select_queue</code>(<code>ixgbe_select_queue</code>),
which will return current cpu index(based 0) when packet select queue.
thus for each cpu use its own tx queue.</p>

<p>but, we found some packet had unmatched queue index when send
on specific cpu.</p>

<p>for example, a packet&rsquo;s queue index is 5 but is sent by cpu3,
thus, cpu3 will operate tx hw queue5, which should only be done by cpu5.</p>

<!-- more -->


<h3>Analysis</h3>

<p>When watchdog is start, it first <code>freeze</code> all subqueues,
and the do the check.
At the end, it resume the subqueues,
and reschedule them.</p>

<p>Because the watchdog is handled in a timer,
so the reschedule the queue will be done on a different cpu,
which is different the packets&rsquo;s queue index.</p>

<p>for example:
packet rung select queue on CPU1, while CPU2 run the watchdog,
this packet will be store in the queue1, but not sent.
when cpu2 finish the watchdog, queue1 is rescheduled.
NOTE here the queue1 start run on cpu2 not cpu1.
which is not expected and safe.
it will cause the tx ring buffer hang.</p>

<h3>related source</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>232 static void dev_watchdog(unsigned long arg)
</span><span class='line'>233 {
</span><span class='line'>234         struct net_device *dev = (struct net_device *)arg;
</span><span class='line'>235
</span><span class='line'>236         netif_tx_lock(dev);
</span><span class='line'>237         if (!qdisc_tx_is_noop(dev)) {
</span><span class='line'>238                 if (netif_device_present(dev) &&
</span><span class='line'>239                     netif_running(dev) &&
</span><span class='line'>240                     netif_carrier_ok(dev)) {
</span><span class='line'>241                         int some_queue_timedout = 0;
</span><span class='line'>242                         unsigned int i;
</span><span class='line'>243                         unsigned long trans_start;
</span><span class='line'>244
</span><span class='line'>245                         for (i = 0; i &lt; dev-&gt;num_tx_queues; i++) {
</span><span class='line'>246                                 struct netdev_queue *txq;
</span><span class='line'>247
</span><span class='line'>248                                 txq = netdev_get_tx_queue(dev, i);
</span><span class='line'>249                                 /*
</span><span class='line'>250                                  * old device drivers set dev-&gt;trans_start
</span><span class='line'>251                                  */
</span><span class='line'>252                                 trans_start = txq-&gt;trans_start ? : dev-&gt;trans_start;
</span><span class='line'>253                                 if (netif_xmit_stopped(txq) &&
</span><span class='line'>254                                     time_after(jiffies, (trans_start +
</span><span class='line'>255                                                          dev-&gt;watchdog_timeo))) {
</span><span class='line'>256                                         some_queue_timedout = 1;
</span><span class='line'>257                                         txq-&gt;trans_timeout++;
</span><span class='line'>258                                         break;
</span><span class='line'>259                                 }
</span><span class='line'>260                         }
</span><span class='line'>261
</span><span class='line'>262                         if (some_queue_timedout) {
</span><span class='line'>263                                 WARN_ONCE(1, KERN_INFO "NETDEV WATCHDOG: %s (%s): transmit queue %u timed out\n",
</span><span class='line'>264                                        dev-&gt;name, netdev_drivername(dev), i);
</span><span class='line'>265                                 dev-&gt;netdev_ops-&gt;ndo_tx_timeout(dev);
</span><span class='line'>266                         }
</span><span class='line'>267                         if (!mod_timer(&dev-&gt;watchdog_timer,
</span><span class='line'>268                                        round_jiffies(jiffies +
</span><span class='line'>269                                                      dev-&gt;watchdog_timeo)))
</span><span class='line'>270                                 dev_hold(dev);
</span><span class='line'>271                 }
</span><span class='line'>272         }
</span><span class='line'>273         netif_tx_unlock(dev);
</span><span class='line'>274
</span><span class='line'>275         dev_put(dev);
</span><span class='line'>276 }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2985 static inline void netif_tx_lock(struct net_device *dev)
</span><span class='line'>2986 {
</span><span class='line'>2987         unsigned int i;
</span><span class='line'>2988         int cpu;
</span><span class='line'>2989
</span><span class='line'>2990         spin_lock(&dev-&gt;tx_global_lock);
</span><span class='line'>2991         cpu = smp_processor_id();
</span><span class='line'>2992         for (i = 0; i &lt; dev-&gt;num_tx_queues; i++) {
</span><span class='line'>2993                 struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
</span><span class='line'>2994
</span><span class='line'>2995                 /* We are the only thread of execution doing a
</span><span class='line'>2996                  * freeze, but we have to grab the _xmit_lock in
</span><span class='line'>2997                  * order to synchronize with threads which are in
</span><span class='line'>2998                  * the -&gt;hard_start_xmit() handler and already
</span><span class='line'>2999                  * checked the frozen bit.
</span><span class='line'>3000                  */
</span><span class='line'>3001                 __netif_tx_lock(txq, cpu);
</span><span class='line'>3002                 set_bit(__QUEUE_STATE_FROZEN, &txq-&gt;state);
</span><span class='line'>3003                 __netif_tx_unlock(txq);
</span><span class='line'>3004         }
</span><span class='line'>3005 }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3013 static inline void netif_tx_unlock(struct net_device *dev)
</span><span class='line'>3014 {
</span><span class='line'>3015         unsigned int i;
</span><span class='line'>3016
</span><span class='line'>3017         for (i = 0; i &lt; dev-&gt;num_tx_queues; i++) {
</span><span class='line'>3018                 struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
</span><span class='line'>3019
</span><span class='line'>3020                 /* No need to grab the _xmit_lock here.  If the
</span><span class='line'>3021                  * queue is not stopped for another reason, we
</span><span class='line'>3022                  * force a schedule.
</span><span class='line'>3023                  */
</span><span class='line'>3024                 clear_bit(__QUEUE_STATE_FROZEN, &txq-&gt;state);
</span><span class='line'>3025                 netif_schedule_queue(txq);
</span><span class='line'>3026         }
</span><span class='line'>3027         spin_unlock(&dev-&gt;tx_global_lock);
</span><span class='line'>3028 }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2265 static inline void netif_schedule_queue(struct netdev_queue *txq)
</span><span class='line'>2266 {
</span><span class='line'>2267         if (!(txq-&gt;state & QUEUE_STATE_ANY_XOFF))
</span><span class='line'>2268                 __netif_schedule(txq-&gt;qdisc);
</span><span class='line'>2269 }</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2150 static inline void __netif_reschedule(struct Qdisc *q)
</span><span class='line'>2151 {
</span><span class='line'>2152         struct softnet_data *sd;
</span><span class='line'>2153         unsigned long flags;
</span><span class='line'>2154
</span><span class='line'>2155         local_irq_save(flags);
</span><span class='line'>2156         sd = &__get_cpu_var(softnet_data);
</span><span class='line'>2157         q-&gt;next_sched = NULL;
</span><span class='line'>2158         *sd-&gt;output_queue_tailp = q;
</span><span class='line'>2159         sd-&gt;output_queue_tailp = &q-&gt;next_sched;
</span><span class='line'>2160         raise_softirq_irqoff(NET_TX_SOFTIRQ);
</span><span class='line'>2161         local_irq_restore(flags);
</span><span class='line'>2162 }
</span><span class='line'>2163
</span><span class='line'>2164 void __netif_schedule(struct Qdisc *q)
</span><span class='line'>2165 {
</span><span class='line'>2166         if (!test_and_set_bit(__QDISC_STATE_SCHED, &q-&gt;state))
</span><span class='line'>2167                 __netif_reschedule(q);
</span><span class='line'>2168 }
</span><span class='line'>2169 EXPORT_SYMBOL(__netif_schedule);</span></code></pre></td></tr></table></div></figure>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Your Name</span></span>

      




<time class='entry-date' datetime='2014-09-17T15:38:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>3:38 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/netcore/'>netcore</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/09/16/ixgbe-queue-index/" title="Previous Post: how does ixgbe use queue index">&laquo; how does ixgbe use queue index</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/10/21/ftrace-study/" title="Next Post: ftrace study">ftrace study &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/21/ftrace-study/">Ftrace Study</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/17/netdevice-watchdog-cause-tx-queue-schedule/">Netdevice Watchdog Cause Tx Queue Schedule</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/16/ixgbe-queue-index/">How Does Ixgbe Use Queue Index</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/14/tcpdump-work-with-bonding-interface/">Tcpdump Work With Bonding Interface</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/31/how-to-select-source-ip-for-a-tcp-socket/">How to Select Source Ip for a Tcp Socket</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/martinbj2008@gmail.com">@martinbj2008@gmail.com</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'martinbj2008@gmail.com',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
