<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Netlink | My Octopress Blog]]></title>
  <link href="http://martinbj2008.github.io/blog/categories/netlink/atom.xml" rel="self"/>
  <link href="http://martinbj2008.github.io/"/>
  <updated>2015-05-21T16:26:25+08:00</updated>
  <id>http://martinbj2008.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PROMISC in NetÂ device->flag]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/06/23/promsic-bit-in-struct-net-devices-flag/"/>
    <updated>2013-06-23T06:01:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/06/23/promsic-bit-in-struct-net-devices-flag</id>
    <content type="html"><![CDATA[<h1>summary</h1>

<p>promisc is one bit of struct net_device&rsquo;s flag,  which is used to indicate if a device is in promisc status.
<code>c
30 /* Standard interface flags (netdevice-&gt;flags). */
31 #define IFF_UP          0x1             /* interface is up              */
32 #define IFF_BROADCAST   0x2             /* broadcast address valid      */
33 #define IFF_DEBUG       0x4             /* turn on debugging            */
34 #define IFF_LOOPBACK    0x8             /* is a loopback net            */
35 #define IFF_POINTOPOINT 0x10            /* interface is has p-p link    */
36 #define IFF_NOTRAILERS  0x20            /* avoid use of trailers        */
37 #define IFF_RUNNING     0x40            /* interface RFC2863 OPER_UP    */
38 #define IFF_NOARP       0x80            /* no ARP protocol              */
39 #define IFF_PROMISC     0x100           /* receive all packets          */
40 #define IFF_ALLMULTI    0x200           /* receive all multicast packets*/
...
</code>
There are two kinds of operataion, could cause a NIC enter/leave promisc status.</p>

<ol>
<li><p>ip command  <br/>
 run mutli <code>on</code> command, just need one <code>off</code> to recover.
<code>sh
 ip link set dev eth0 promisc on
 ip link set dev eth0 promisc off
</code></p></li>
<li><p>tcpdump command  <br/>
When tcpdump starts, it let dev to promisc,
and just before exit, tcpdump let dev left promisc.
All these is done by call kernel api dev_set_promiscuity.</p></li>
</ol>


<!-- more -->


<h2>Data struct and function</h2>

<h2>summary</h2>

<p>kernel 3.10 rc6</p>

<p>There is a element <code>promiscuity</code> in <code>struct net device</code>,
which is reference for NIC promisc status.
Every time we want to set promisc to NIC, the reference increase 1,
while unset promisc, the value sub 1.</p>

<pre><code class="c">1156         unsigned int            promiscuity;
</code></pre>

<p>When the value change from 0 to 1, or become 0,
that netdevice&rsquo;s ops is called to set/unset promisic status.</p>

<h2>call trace</h2>

<pre><code class="c">&gt; dev_set_promiscuity    
&gt;&gt; __dev_set_promiscuity    
&gt;&gt;&gt; dev-&gt;promiscuity += inc;    
&gt;&gt;&gt;&gt; dev-&gt;flags |= IFF_PROMISC or  &amp;= ~IFF_PROMISC    
&gt;&gt;&gt; dev_change_rx_flags(dev, IFF_PROMISC);    
&gt;&gt;&gt;&gt; ops-&gt;ndo_change_rx_flags(dev, flags);&lt;== for most nic, the method is null.        
&gt;&gt; dev_set_rx_mode    
&gt;&gt;&gt; const struct net_device_ops *ops = dev-&gt;netdev_ops;    
&gt;&gt;&gt; ops-&gt;ndo_set_rx_mode(dev);
&gt;&gt;&gt; for e100, e100_set_multicast_list 
</code></pre>

<h2>dev_set_promiscuity</h2>

<p>call __dev_set_promiscuity to record the reference of promisc,
If real need change status(refer from 0 to 1, or from 1 to 0),
call dev_set_rx_mode to really change NIC promisc status.</p>

<pre><code class="c">4490 /**
4491  *      dev_set_promiscuity     - update promiscuity count on a device
4492  *      @dev: device
4493  *      @inc: modifier
4494  *
4495  *      Add or remove promiscuity from a device. While the count in the device
4496  *      remains above zero the interface remains promiscuous. Once it hits zero
4497  *      the device reverts back to normal filtering operation. A negative inc
4498  *      value is used to drop promiscuity on the device.
4499  *      Return 0 if successful or a negative errno code on error.
4500  */
4501 int dev_set_promiscuity(struct net_device *dev, int inc)
4502 {
4503         unsigned int old_flags = dev-&gt;flags;
4504         int err;
4505
4506         err = __dev_set_promiscuity(dev, inc);
4507         if (err &lt; 0)
4508                 return err;
4509         if (dev-&gt;flags != old_flags)
4510                 dev_set_rx_mode(dev);
4511         return err;
4512 }
4513 EXPORT_SYMBOL(dev_set_promiscuity);
</code></pre>

<h2>__dev_set_promiscuity</h2>

<p>set the
<code>c
static int __dev_set_promiscuity(struct net_device *dev, int inc)
4445 {
4446         unsigned int old_flags = dev-&gt;flags;
...
4452         dev-&gt;flags |= IFF_PROMISC;
4453         dev-&gt;promiscuity += inc;
4454         if (dev-&gt;promiscuity == 0) {
...
4460                         dev-&gt;flags &amp;= ~IFF_PROMISC;
...
4467         }
4468         if (dev-&gt;flags != old_flags) {
...
4485                 dev_change_rx_flags(dev, IFF_PROMISC);
4486         }
</code></p>

<pre><code class="c">4436 static void dev_change_rx_flags(struct net_device *dev, int flags)
4437 {
4438         const struct net_device_ops *ops = dev-&gt;netdev_ops;
4439/*Junwei most nic has no this ops ndo_change_rx_flags*/
4440         if ((dev-&gt;flags &amp; IFF_UP) &amp;&amp; ops-&gt;ndo_change_rx_flags)
4441                 ops-&gt;ndo_change_rx_flags(dev, flags);
4442 }
</code></pre>

<pre><code class="c">4592 void dev_set_rx_mode(struct net_device *dev)
4593 {
4594         netif_addr_lock_bh(dev);
4595         __dev_set_rx_mode(dev);
4596         netif_addr_unlock_bh(dev);
4597 }
</code></pre>

<pre><code class="c">4558 /*
4559  *      Upload unicast and multicast address lists to device and
4560  *      configure RX filtering. When the device doesn't support unicast
4561  *      filtering it is put in promiscuous mode while unicast addresses
4562  *      are present.
4563  */
4564 void __dev_set_rx_mode(struct net_device *dev)
4565 {
4566         const struct net_device_ops *ops = dev-&gt;netdev_ops;
4567
4568         /* dev_open will call this function so the list will stay sane. */
4569         if (!(dev-&gt;flags&amp;IFF_UP))
4570                 return;
4571
4572         if (!netif_device_present(dev))
4573                 return;
4574
4575         if (!(dev-&gt;priv_flags &amp; IFF_UNICAST_FLT)) {
4576                 /* Unicast addresses changes may only happen under the rtnl,
4577                  * therefore calling __dev_set_promiscuity here is safe.
4578                  */
4579                 if (!netdev_uc_empty(dev) &amp;&amp; !dev-&gt;uc_promisc) {
4580                         __dev_set_promiscuity(dev, 1);
4581                         dev-&gt;uc_promisc = true;
4582                 } else if (netdev_uc_empty(dev) &amp;&amp; dev-&gt;uc_promisc) {
4583                         __dev_set_promiscuity(dev, -1);
4584                         dev-&gt;uc_promisc = false;
4585                 }
4586         }
4587
4588         if (ops-&gt;ndo_set_rx_mode)
4589                 ops-&gt;ndo_set_rx_mode(dev); &lt;===
4590 }
</code></pre>

<p>for example e100 nic, ops->ndo_set_rx_mode is in file
drivers/net/ethernet/intel/e100.c</p>

<pre><code class="c">2830 static const struct net_device_ops e100_netdev_ops = {
2835         .ndo_set_rx_mode        = e100_set_multicast_list, &lt;===
</code></pre>

<pre><code class="c">1609 static void e100_set_multicast_list(struct net_device *netdev)
1610 {
...
1617         if (netdev-&gt;flags &amp; IFF_PROMISC)
1618                 nic-&gt;flags |= promiscuous;
1619         else
1620                 nic-&gt;flags &amp;= ~promiscuous;
...
1628         e100_exec_cb(nic, NULL, e100_configure);
1629         e100_exec_cb(nic, NULL, e100_multi);
1630 }
</code></pre>

<h2>how tcpdump use</h2>

<pre><code class="c">&gt; packet_setsockopt
&gt;&gt; packet_mc_add
&gt;&gt;&gt; packet_dev_mc
&gt;&gt;&gt;&gt; dev_set_promiscuity
</code></pre>

<h2>how ip command use</h2>

<p><strong><em>NOTE</em></strong>
for netlink message:
the promisc flag is not store in dev->flags, but <strong><em>dev->gflags</em></strong>.</p>

<p>so the</p>

<pre><code class="c">&gt; rtnl_setlink
&gt;&gt; do_setlink
&gt;&gt;&gt; dev_change_flags
&gt;&gt;&gt;&gt; __dev_change_flags
&gt;&gt;&gt;&gt;&gt;4670         if ((flags ^ dev-&gt;gflags) &amp; IFF_PROMISC) {
&gt;&gt;&gt;&gt;&gt;4671                 int inc = (flags &amp; IFF_PROMISC) ? 1 : -1;
&gt;&gt;&gt;&gt;&gt;4672 
&gt;&gt;&gt;&gt;&gt;4673                 dev-&gt;gflags ^= IFF_PROMISC;
&gt;&gt;&gt;&gt;&gt;4674                 dev_set_promiscuity(dev, inc);
&gt;&gt;&gt;&gt;&gt;4675         }
&gt;&gt;&gt;&gt; rtmsg_ifinfo       &lt;=== netlink broadcast
&gt;&gt;&gt;&gt; __dev_notify_flags &lt;=== callback notify
</code></pre>

<pre><code class="c">2726 void __init rtnetlink_init(void)
2727 {
2728         if (register_pernet_subsys(&amp;rtnetlink_net_ops))
2729                 panic("rtnetlink_init: cannot initialize rtnetlink\n");
2730
2731         register_netdevice_notifier(&amp;rtnetlink_dev_notifier);
2732
2733         rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,
2734                       rtnl_dump_ifinfo, rtnl_calcit);
2735         rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, NULL);
2736         rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, NULL);
2737         rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, NULL);
</code></pre>

<pre><code class="c">1516 static int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh)
...
1552         err = do_setlink(dev, ifm, tb, ifname, 0);
...
</code></pre>

<pre><code class="c">1286 static int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,
1287                       struct nlattr **tb, char *ifname, int modified)
...
1395         if (ifm-&gt;ifi_flags || ifm-&gt;ifi_change) {
1396                 err = dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm));
1397                 if (err &lt; 0)
1398                         goto errout;
1399         }
</code></pre>

<pre><code class="c">4715 int dev_change_flags(struct net_device *dev, unsigned int flags)
4716 {
4717         int ret;
4718         unsigned int changes, old_flags = dev-&gt;flags;
4719
4720         ret = __dev_change_flags(dev, flags);
4721         if (ret &lt; 0)
4722                 return ret;
4723
4724         changes = old_flags ^ dev-&gt;flags;
4725         if (changes)
4726                 rtmsg_ifinfo(RTM_NEWLINK, dev, changes);
4727
4728         __dev_notify_flags(dev, old_flags);
4729         return ret;
4730 }
</code></pre>

<pre><code class="c">4630 int __dev_change_flags(struct net_device *dev, unsigned int flags)
4631 {
4632         unsigned int old_flags = dev-&gt;flags;
4633         int ret;
4634
4635         ASSERT_RTNL();
4636
4637         /*
4638          *      Set the flags on our device.
4639          */
4640
4641         dev-&gt;flags = (flags &amp; (IFF_DEBUG | IFF_NOTRAILERS | IFF_NOARP |
4642                                IFF_DYNAMIC | IFF_MULTICAST | IFF_PORTSEL |
4643                                IFF_AUTOMEDIA)) |
4644                      (dev-&gt;flags &amp; (IFF_UP | IFF_VOLATILE | IFF_PROMISC |
4645                                     IFF_ALLMULTI));
4646
4647         /*
4648          *      Load in the correct multicast list now the flags have changed.
4649          */
4650
4651         if ((old_flags ^ flags) &amp; IFF_MULTICAST)
4652                 dev_change_rx_flags(dev, IFF_MULTICAST);
4653
4654         dev_set_rx_mode(dev);
4655
4656         /*
4657          *      Have we downed the interface. We handle IFF_UP ourselves
4658          *      according to user attempts to set it, rather than blindly
4659          *      setting it.
4660          */
4661
4662         ret = 0;
4663         if ((old_flags ^ flags) &amp; IFF_UP) {     /* Bit is different  ? */
4664                 ret = ((old_flags &amp; IFF_UP) ? __dev_close : __dev_open)(dev);
4665
4666                 if (!ret)
4667                         dev_set_rx_mode(dev);
4668         }
4669
4670         if ((flags ^ dev-&gt;gflags) &amp; IFF_PROMISC) {
4671                 int inc = (flags &amp; IFF_PROMISC) ? 1 : -1;
4672
4673                 dev-&gt;gflags ^= IFF_PROMISC;
4674                 dev_set_promiscuity(dev, inc);
4675         }
4676
4677         /* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI
4678            is important. Some (broken) drivers set IFF_PROMISC, when
4679            IFF_ALLMULTI is requested not asking us and not reporting.
4680          */
4681         if ((flags ^ dev-&gt;gflags) &amp; IFF_ALLMULTI) {
4682                 int inc = (flags &amp; IFF_ALLMULTI) ? 1 : -1;
4683
4684                 dev-&gt;gflags ^= IFF_ALLMULTI;
4685                 dev_set_allmulti(dev, inc);
4686         }
4687
4688         return ret;
4689 }
</code></pre>

<pre><code> 648 static unsigned int rtnl_dev_combine_flags(const struct net_device *dev,
 649                                            const struct ifinfomsg *ifm)
 650 {
 651         unsigned int flags = ifm-&gt;ifi_flags;
 652
 653         /* bugwards compatibility: ifi_change == 0 is treated as ~0 */
 654         if (ifm-&gt;ifi_change)
 655                 flags = (flags &amp; ifm-&gt;ifi_change) |
 656                         (rtnl_dev_get_flags(dev) &amp; ~ifm-&gt;ifi_change);
 657
 658         return flags;
 659 }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netlink in Kernel(continue)]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/03/15/netlink-in-kernel/"/>
    <updated>2013-03-15T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/03/15/netlink-in-kernel</id>
    <content type="html"><![CDATA[<h2>netlinkä»ç»</h2>

<p>  netlinkæ¯ä¸ç§ç¨äºåæ ¸åç¨æ·ç©ºé´è¿è¡æ°æ®äº¤äºçsocketã å³äºnetlinkçå·ä½ä»ç»ï¼googleç»åºæ´å¥½çè§£éã
  netlinkæ¯socketçä¸ç§ï¼å¶çfamilyå·æ¯PF_NETLINK, netlinkåæ¬å¾å¤ç§protoï¼å¹¶ä¸ç¨æ·å¯ä»¥æ ¹æ®èªå·±çéè¦è¿è¡æ©å±ã
æ¯ä¸ªnetlinksocketé½æä¸ä¸ªpidï¼è¯¥pidå¨æå±protoä¸æ¯å¯ä¸çã å¨netlinkæ¶æ¯
ä¼ éæ¯ï¼pidå¸¸è¢«ç¨æ¥æ è¯ç®çå°socketã</p>

<p>Every netlink socket is indicated by (net, proto, pid).</p>

<ol>
<li>net: the net namespace.</li>
<li>proto: netlink proto.</li>
<li>pid:</li>
</ol>


<!-- more -->


<p>netlinkçæ¶æ¯å¯ä»¥åä¸ºä¸¤ç§ç±»åï¼ åæ­(unicast)åç»æ­(broadcast).</p>

<ol>
<li>åæ­ï¼ç®çsocketæ¯åºå®çã</li>
<li>ç»æ­ï¼ç®çsocketå¯ä»¥æ¯ä¸ä¸ªï¼æèå¤ä¸ªï¼çè³è¿å¯è½æ¯æ²¡æã ç»æ­æ¶æ¯ä¸ºè¢«åéå°æ¯ä¸ä¸ªçå¬å¯¹åºgroupçsocketçæ¥åéåä¸ã</li>
</ol>


<p>netlinkçä½¿ç¨è·æ®ésocketåºæ¬ç¸åã âcreate/bind send/recvâ</p>

<p>æ¯ä¸ªnetlink socketå¨åå»ºæ¶åå¿é¡»ææ family åprotoã familyå½ç¶æ¯netlinkï¼ protoå¯ä»¥ä¸ªnetlinkæ¯æçä»»æä¸ä¸ªã</p>

<p>æ¯ä¸ªprotoä¸é½å¯ä»¥æåå«å¾å¤ä¸ªç»æ­ç»ï¼groupï¼ã å¦xfrm protoä¸é¢åå«</p>

<p>æ¯ä¸ªsocketçåå»ºæ¯é½å¯ä»¥æå®å¯¹ä¸ä¸ªæèå ä¸ªgroupæå´è¶£ï¼ é£ä¹åæ ¸å°±èªå¨å°ç¸å³çgroupä¸çç»æ­æ¶æ¯ç»æ­å°è¯¥socketä¸ã è¯¥socketéè¿recvå½æ°æ¥åè¿äºç»æ­æ¶æ¯ã</p>

<p>æ³¨ï¼æ¯ä¸ªnetlinksocketå¨åå»ºçæ¶åå¿é¡»æææå±çprotoã å æ­¤æ¯ä¸ªnetlink socketåªè½çå¬å¶æå¨protoä¸çgroupç»æ­æ¶æ¯ã</p>

<p>exampleï¼ dumpåºåæ ¸éææçinterfaceï¼ é£ä¹æåå»ºä¸ä¸ªnetlink socketï¼ ç¶åè°ç¨send/rcvè®©åæ ¸å§ææçinterfaceä¿¡æ¯è¾åºã</p>

<p>å¦ææä»¬è¿è¦æ±ï¼ çæ§interfaceç¶ææ¹åï¼ æ¯å¦ å½âinterface down/upâ æä»¬ç¬¬ä¸æ¶é´ç¥éinterfaceçæ°ç¶æã é£ä¹æä»¬å¨åå»ºsockçæ¶åéææè¦çå¬groupXX. groupå¯ä»¥å¨åå»ºsocketæ¶åææï¼ ä¹å¯ä»¥å¨socketåå»ºåï¼éè¿set sockoptæ¥æ´æ¹ã å½ç¶ä¹å¯å¨ç¨åºè¿è¡è¿ç¨ä¸­éè¿sockoptæ´æ¹ã è¿ä¸ªgroupä¿¡æ¯ä¼ä¿å­å¨netlink sockçgroupéï¼ åæ¶ä¹ä¼æ´æ°å¯¹åºprotoä¸çgroupä¿¡æ¯ã</p>

<p>è§ç¤ºä¾ä»£ç ãxxx todo.</p>

<p>netlink_table</p>

<p>netlinkæ¯æçææprotoé½ä¿å­å¨ä¸ä¸ªæ°ç»nl_tableä¸­.
<code>c
static struct netlink_table *nl_table;
</code></p>

<p>ä¹å°±æ¯æ¯ä¸ªprotoé½å¯¹åºä¸ä¸ª<code>struct netlink_table</code>.</p>

<pre><code class="c">119 struct netlink_table {
120         struct nl_pid_hash hash;          /* store all the netlink socket with hash list */
121         struct hlist_head mc_list;            /* store all the netlink socket listen broadcast netlink message */
122         struct listeners __rcu *listeners;      /* store with a bit(1) for each netlink broadcast type, which is listened by one or more netlink sockets in mc_list(line 121) */
123         unsigned int nl_nonroot;
124         unsigned int groups;            /* the counts of bits in listeners(line 122)*/
125         struct mutex *cb_mutex;
126         struct module *module;
127         int registered;             /* avoid repeated register. */
128 };
</code></pre>

<p>éå¯¹ç¹å®çä¸ä¸ªproto:</p>

<ol>
<li>hash: ææçprotoç±»åçnetlink socket é½æ¾å°è¿ä¸ªhashé¾è¡¨éã</li>
<li>mc_list: hashé¾è¡¨ãè®°å½å¸æçå¬ç»æ­æ¶æ¯çnetlink socket.</li>
<li>listeners: è®°å½åªäºgroupè¢«çå¬, ä¸ä¸ªgroupå 1ä½.</li>
<li>nl_noroot: todo!</li>
<li>groups: è¢«çå¬çgroupçæ»ä¸ªæ°</li>
<li>cb_mutex: callback å½æ°ç¨å°çé</li>
<li>module: å¨lsmæ¨¡å¼ä¸ä½¿ç¨ï¼ä¸ä¸¥æ ¼ï¼ã</li>
<li>register: æ¯å¦è¢«æ³¨åï¼å ç¨ï¼ã</li>
</ol>


<p>åä¸ä¸ªprotoä¸çæænetlink socketé½ä¼æè½½å° hashé¾ä¸ï¼ è¿äºsocketä¸­å¡æ¯å¯¹å¸æçå¬groupç»æ­æ¶æ¯çï¼ é½è¿ä¼è¢«æè½½å°mc_listä¸ã ä¸è®ºæ¯è¦çå¬å¤å°ä¸ªgroupï¼æ¯ä¸ªsocké½åªä½ä¸ºmc_listä¸ä¸ªèç¹ï¼ä¸ä¼éå¤ã</p>

<p>å½æç»æ­æ¶æ¯äº§çæ¶ï¼kernelé¦åæ¥çnetlink_table->groupsæ¯å¦ä¸º0ï¼ å¦æä¸º0ï¼ é£ä¹æ²¡æä»»ä½ä¸ä¸ªgroupæ²¡çå¬ãæ¾ç¶ï¼è¿ç§æåµä¸ï¼kernelå¥ä¹ä¸ç¨åã ç´æ¥éåºã</p>

<p>å¦ænetlink_table->groupsä¸ä¸º0ï¼é£ä¹kernelä¼éåmc_listï¼ ååºæ¯ä¸ªnetlink socketæ¥çå½åç»æ­æ¶æ¯çç±»åæ¯å¦æ¯ å¨è¯¥socketæçå¬çgoupséï¼å¦ææ¯é£ä¹åéå½åæ¶æ¯å°è¯¥socketçæ¥åéåéã å¦åå¥ä¹ä¸åï¼ç»§ç»­éåmc_listéä¸ä¸ä¸ªnetlink socket.</p>

<p>å¦æè¦æéåæ­æ¶æ¯é£ä¹ç´æ¥æ ¹æ® netlink sockçpidï¼ å¨hashé¾éæ¾å°å¯¹åºçsocketå¹¶åéæ¶æ¯å¯æ¬(skb clone or copy)å°å¯¹åºçskæ¥æ¶éå åæ¶æ¿ådata_ready.</p>

<p>[netlink_tableçè¯»åä¿æ¤] (<a href="http://martinbj2008.github.com/kernel/2013/03/11/netlink-grab/">http://martinbj2008.github.com/kernel/2013/03/11/netlink-grab/</a>)</p>

<p>ç»¼è¿°</p>

<p>æ¯ä¸ªnetlink socket è¢«åå»ºçæ¶åï¼protoå·²ç»è¢«æå®ã 1. ä¿å­äºèªå·±çgroupsï¼ç¨æ¥è¡¨æèªå·±å¯¹è«ä¸ª(äºï¼groupæå´è¶£ã 2. æå¨èªå·±çsocketçå°netlink_table->hashä¸ã 3. æ ¹æ®å¶æ¯å¦å¯¹ç»æ­æå´è¶£ï¼sock->groups == 0 ?) ï¼å³å®æ¯å¦æå°netlink_table->mc_listä¸ å¹¶æ ¹æ®éè¦æ´è¡netlink_tableä¸çlistenersçæ å¿ä½ågroupsï¼</p>

<p>æ¯ä¸ªprotoå¨åå§åæ¶é½: 1. åå»ºä¸ä¸ªåæ ¸ænetlink socketã(pid ä¸º0) 2. æ³¨åå°ä¸ä¸ªnetlink_tableï¼ ï¼lbackå½æ°,ç¨äºæ¥åå¹¶å¤çè¯¥ç±»åçnetlinkæ¶æ¯ã In initialization, each type netlink call netlink_kernel_create, which will prepare two parts: 1. Register in a netlink_table of nl_table, 2. Create a netlink kernel socket for the registered proto.</p>

<p>è¦ç»æ­ä¸ä¸ªnetlinkæ¶æ¯,æå®groupså³å¯ã è¦åä¸ä¸ªnetlinkæ¶æ¯ç»ç¹å®çnetlink socketåªéææå¶pidå³å¯ã ææåéç»åæ ¸çåæ­æ¶æ¯pidä¸º0ã åæ ¸æ ¹æ®protoèªå¨è°ç¨ç¸åºprotoçcallbackå½æ°ï¼ æ ¹æ®å·ä½æ¶æ¯åå®¹ï¼æçè¿éè¦kernelä¸ºå¤çç»æåéä¸ä¸ªæ°çnetlinkmessage ç»åéæ¹çnetlink sockã</p>

<p>netlink socket proto</p>

<p>neilinkæ¯æçprotoç±»åéå¸¸å¤ãä¸å¯ä»¥èªå®ä¹æ©å±(ä¸å»ºè®®), å»ºè®®ä½¿ç¨genericè¿è¡æ©å±ã</p>

<pre><code class="c">  7 #define NETLINK_ROUTE           0       /* Routing/device hook                          */
  8 #define NETLINK_UNUSED          1       /* Unused number                                */
  9 #define NETLINK_USERSOCK        2       /* Reserved for user mode socket protocols      */
 10 #define NETLINK_FIREWALL        3       /* Firewalling hook                             */
 11 #define NETLINK_SOCK_DIAG       4       /* socket monitoring                            */
 12 #define NETLINK_NFLOG           5       /* netfilter/iptables ULOG */
 13 #define NETLINK_XFRM            6       /* ipsec */
 14 #define NETLINK_SELINUX         7       /* SELinux event notifications */
 15 #define NETLINK_ISCSI           8       /* Open-iSCSI */
 16 #define NETLINK_AUDIT           9       /* auditing */
 17 #define NETLINK_FIB_LOOKUP      10
 18 #define NETLINK_CONNECTOR       11
 19 #define NETLINK_NETFILTER       12      /* netfilter subsystem */
 20 #define NETLINK_IP6_FW          13
 21 #define NETLINK_DNRTMSG         14      /* DECnet routing messages */
 22 #define NETLINK_KOBJECT_UEVENT  15      /* Kernel messages to userspace */
 23 #define NETLINK_GENERIC         16
 24 /* leave room for NETLINK_DM (DM Events) */
 25 #define NETLINK_SCSITRANSPORT   18      /* SCSI Transports */
 26 #define NETLINK_ECRYPTFS        19
 27 #define NETLINK_RDMA            20
 28 #define NETLINK_CRYPTO          21      /* Crypto layer */
 29
 30 #define NETLINK_INET_DIAG       NETLINK_SOCK_DIAG
 31
 32 #define MAX_LINKS 32
</code></pre>

<p>ä»¥ä¸xfrm netlinkä¸ºä¾ï¼è¿è¡æè¿°ã</p>

<p>Each proto of netlink has many groups, for example xfrm netlink:
<code>
462 enum xfrm_nlgroups {
463         XFRMNLGRP_NONE,
464 #define XFRMNLGRP_NONE          XFRMNLGRP_NONE
465         XFRMNLGRP_ACQUIRE,
466 #define XFRMNLGRP_ACQUIRE       XFRMNLGRP_ACQUIRE
467         XFRMNLGRP_EXPIRE,
468 #define XFRMNLGRP_EXPIRE        XFRMNLGRP_EXPIRE
469         XFRMNLGRP_SA,
470 #define XFRMNLGRP_SA            XFRMNLGRP_SA
471         XFRMNLGRP_POLICY,
472 #define XFRMNLGRP_POLICY        XFRMNLGRP_POLICY
473         XFRMNLGRP_AEVENTS,
474 #define XFRMNLGRP_AEVENTS       XFRMNLGRP_AEVENTS
475         XFRMNLGRP_REPORT,
476 #define XFRMNLGRP_REPORT        XFRMNLGRP_REPORT
477         XFRMNLGRP_MIGRATE,
478 #define XFRMNLGRP_MIGRATE       XFRMNLGRP_MIGRATE
479         XFRMNLGRP_MAPPING,
480 #define XFRMNLGRP_MAPPING       XFRMNLGRP_MAPPING
481         __XFRMNLGRP_MAX
482 };
483 #define XFRMNLGRP_MAX   (__XFRMNLGRP_MAX - 1)
</code></p>

<h2>Data struct &amp;&amp; method</h2>

<h3>struct netlink_sock</h3>

<pre><code class="c">67 struct netlink_sock {
68         /* struct sock has to be the first member of netlink_sock */
69         struct sock             sk;
70         u32                     pid;
71         u32                     dst_pid;
72         u32                     dst_group;
73         u32                     flags;
74         u32                     subscriptions;
75         u32                     ngroups;
76         unsigned long           *groups;
77         unsigned long           state;
78         wait_queue_head_t       wait;
79         struct netlink_callback *cb;
80         struct mutex            *cb_mutex;
81         struct mutex            cb_def_mutex;
82         void                    (*netlink_rcv)(struct sk_buff *skb);
83         struct module           *module;
84 };
</code></pre>

<p>Every netlink socket has a pid. The pid of netlink kernel sockets is 0. All the the netlink message need kernel process, will be sent to them. (net, pid, protocol) will be used to locate the destination of a netlink message.</p>

<h3>xfrm netlink Register</h3>

<p>To register a new netlink proto, two elements are needed in a struct netlink_kernel_cfg, a. groups: the MAX groups in this proto. b. input: a callback funciton for all received netlink message whose type is âprotoâ. Register a netlink type with NETLINK_XFRM, which has XFRMNLGRP_MAX groups. and all the netlink message will be processed by xfrm_netlink_rcv.</p>

<p>We skip pernet initilization for xfrm, See XXX for detail about pernet ops. Finaly, xfrm_user_net_init is called.</p>

<h3>xx?</h3>

<ol>
<li>xfrm_user_net_init</li>
</ol>


<p>  1.1 call netlink_kernel_create</p>

<p>  1.2 init the xfrm netlink part of corresponding net namespace.</p>

<ol>
<li><p>netlink_kernel_create(__netlink_kernel_create)</p>

<p>2.1 create a netlink xfrm socket(kernel), which will be used a netlink kernel socket to rcv(queue) all the message send to âkernel/xfrmâ</p>

<p>2.2 regiser the xfrm proto in the netlink_table.
<code>__netlink_create</code>[socket_sock_png]: <a href="http://martinbj2008.github.com/pic/socket_sock.png">http://martinbj2008.github.com/pic/socket_sock.png</a> [Source]<a href="https://gist.github.com/martinbj2008/5096075#file-gistfile3-c">https://gist.github.com/martinbj2008/5096075#file-gistfile3-c</a></p></li>
</ol>


<h2>user socket creation</h2>

<p>netlink_sendmsg</p>

<p>netlink_sendmsg ââ> netlink_unicastg ââ> nlk->netlink_rcv,</p>

<p>Create a skb and init NETLINK_CB(skb), Copy the message data with memcpy_fromiovec.</p>

<p>If its destination is a group, then broadcast it with netlink_broadcast, or it is a unicast message, send it by netlink_unicast.</p>

<p>nlk->netlink_rcv is set in netlink_create fox xfrm netlink message, it is xfrm_netlink_rcv</p>

<pre><code class="c">1313 static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
1314                            struct msghdr *msg, size_t len)
1315 {
1316         struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
1317         struct sock *sk = sock-&gt;sk;
1318         struct netlink_sock *nlk = nlk_sk(sk);
1319         struct sockaddr_nl *addr = msg-&gt;msg_name;
1320         u32 dst_pid;
1321         u32 dst_group;
1322         struct sk_buff *skb;
1323         int err;
1324         struct scm_cookie scm;
1325
1326         if (msg-&gt;msg_flags&amp;MSG_OOB)
1327                 return -EOPNOTSUPP;
1328
1329         if (NULL == siocb-&gt;scm)
1330                 siocb-&gt;scm = &amp;scm;
1331
1332         err = scm_send(sock, msg, siocb-&gt;scm, true);
1333         if (err &lt; 0)
1334                 return err;
1335
1336         if (msg-&gt;msg_namelen) {
1337                 err = -EINVAL;
1338                 if (addr-&gt;nl_family != AF_NETLINK)
1339                         goto out;
1340                 dst_pid = addr-&gt;nl_pid;
1341                 dst_group = ffs(addr-&gt;nl_groups);
1342                 err =  -EPERM;
1343                 if ((dst_group || dst_pid) &amp;&amp;
1344                     !netlink_capable(sock, NL_NONROOT_SEND))
1345                         goto out;
1346         } else {
1347                 dst_pid = nlk-&gt;dst_pid;
1348                 dst_group = nlk-&gt;dst_group;
1349         }
1350
1351         if (!nlk-&gt;pid) {
1352                 err = netlink_autobind(sock);
1353                 if (err)
1354                         goto out;
1355         }
1356
1357         err = -EMSGSIZE;
1358         if (len &gt; sk-&gt;sk_sndbuf - 32)
1359                 goto out;
1360         err = -ENOBUFS;
1361         skb = alloc_skb(len, GFP_KERNEL);
1362         if (skb == NULL)
1363                 goto out;
1364
1365         NETLINK_CB(skb).pid     = nlk-&gt;pid;
1366         NETLINK_CB(skb).dst_group = dst_group;
1367         memcpy(NETLINK_CREDS(skb), &amp;siocb-&gt;scm-&gt;creds, sizeof(struct ucred));
1368
1369         err = -EFAULT;
1370         if (memcpy_fromiovec(skb_put(skb, len), msg-&gt;msg_iov, len)) {
1371                 kfree_skb(skb);
1372                 goto out;
1373         }
1374
1375         err = security_netlink_send(sk, skb);
1376         if (err) {
1377                 kfree_skb(skb);
1378                 goto out;
1379         }
1380
1381         if (dst_group) {
1382                 atomic_inc(&amp;skb-&gt;users);
1383                 netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
1384         }
1385         err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);
1386
1387 out:
1388         scm_destroy(siocb-&gt;scm);
1389         return err;
1390 }
</code></pre>

<h3>netlink_unicast</h3>

<p>find the dest netlink socket by its pid.
if dst socket is a kernl socket, call netlink_unicast_kernel. for example : in the case, dump xfrm sa. else put the skb into the dest socket recv queue.
891 int netlink_unicast(struct sock ssk, struct sk_buff skb, 892 u32 pid, int nonblock) 893 { 894 struct sock *sk; 895 int err; 896 long timeo; 897 898 skb = netlink_trim(skb, gfp_any()); 899 900 timeo = sock_sndtimeo(ssk, nonblock); 901 retry: 902 sk = netlink_getsockbypid(ssk, pid); 903 if (IS_ERR(sk)) { 904 kfree_skb(skb); 905 return PTR_ERR(sk); 906 } 907 if (netlink_is_kernel(sk)) 908 return netlink_unicast_kernel(sk, skb); 909 910 if (sk_filter(sk, skb)) { 911 err = skb->len; 912 kfree_skb(skb); 913 sock_put(sk); 914 return err; 915 } 916 917 err = netlink_attachskb(sk, skb, &amp;timeo, ssk); 918 if (err == 1) 919 goto retry; 920 if (err) 921 return err; 922 923 return netlink_sendskb(sk, skb); 924 } 925 EXPORT_SYMBOL(netlink_unicast);</p>

<p>broadcast message</p>

<pre><code class="c"> 905 int netlink_unicast(struct sock *ssk, struct sk_buff *skb,
 906                     u32 pid, int nonblock)
 907 {
 908         struct sock *sk;
 909         int err;
 910         long timeo;
 911
 912         skb = netlink_trim(skb, gfp_any());
 913
 914         timeo = sock_sndtimeo(ssk, nonblock);
 915 retry:
 916         sk = netlink_getsockbypid(ssk, pid);
 917         if (IS_ERR(sk)) {
 918                 kfree_skb(skb);
 919                 return PTR_ERR(sk);
 920         }
 921         if (netlink_is_kernel(sk))
 922                 return netlink_unicast_kernel(sk, skb);
 923
 924         if (sk_filter(sk, skb)) {
 925                 err = skb-&gt;len;
 926                 kfree_skb(skb);
 927                 sock_put(sk);
 928                 return err;
 929         }
 930
 931         err = netlink_attachskb(sk, skb, &amp;timeo, ssk);
 932         if (err == 1)
 933                 goto retry;
 934         if (err)
 935                 return err;
 936
 937         return netlink_sendskb(sk, skb);
 938 }
</code></pre>

<pre><code class="c"> 889 static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb)
 890 {
 891         int ret;
 892         struct netlink_sock *nlk = nlk_sk(sk);
 893
 894         ret = -ECONNREFUSED;
 895         if (nlk-&gt;netlink_rcv != NULL) {
 896                 ret = skb-&gt;len;
 897                 skb_set_owner_r(skb, sk);
 898                 nlk-&gt;netlink_rcv(skb);
 899         }
 900         kfree_skb(skb);
 901         sock_put(sk);
 902         return ret;
 903 }
</code></pre>

<pre><code class="c">  86 struct listeners {
  87         struct rcu_head         rcu;
  88         unsigned long           masks[0];
  89 };
</code></pre>

<pre><code class="c"> 106 struct nl_pid_hash {
 107         struct hlist_head *table;
 108         unsigned long rehash_time;
 109
 110         unsigned int mask;
 111         unsigned int shift;
 112
 113         unsigned int entries;
 114         unsigned int max_shift;
 115
 116         u32 rnd;
 117 };
</code></pre>

<pre><code class="c">  55 struct rtnl_link {
  56         rtnl_doit_func          doit;
  57         rtnl_dumpit_func        dumpit;
  58         rtnl_calcit_func        calcit;
  59 };
</code></pre>

<pre><code class="c">101 static struct rtnl_link *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];
pernet ops
</code></pre>

<pre><code class="c">2124 static struct pernet_operations __net_initdata netlink_net_ops = {
2125         .init = netlink_net_init,
2126         .exit = netlink_net_exit,
2127 };
</code></pre>

<h3>socket related ops</h3>

<pre><code> 396 static struct proto netlink_proto = {
 397         .name     = "NETLINK",
 398         .owner    = THIS_MODULE,
 399         .obj_size = sizeof(struct netlink_sock),
 400 };
</code></pre>

<pre><code class="c">2061 static const struct proto_ops netlink_ops = {
2062         .family =       PF_NETLINK,
2063         .owner =        THIS_MODULE,
2064         .release =      netlink_release,
2065         .bind =         netlink_bind,
2066         .connect =      netlink_connect,
2067         .socketpair =   sock_no_socketpair,
2068         .accept =       sock_no_accept,
2069         .getname =      netlink_getname,
2070         .poll =         datagram_poll,
2071         .ioctl =        sock_no_ioctl,
2072         .listen =       sock_no_listen,
2073         .shutdown =     sock_no_shutdown,
2074         .setsockopt =   netlink_setsockopt,
2075         .getsockopt =   netlink_getsockopt,
2076         .sendmsg =      netlink_sendmsg,
2077         .recvmsg =      netlink_recvmsg,
2078         .mmap =         sock_no_mmap,
2079         .sendpage =     sock_no_sendpage,
2080 };
</code></pre>

<pre><code class="c">2082 static const struct net_proto_family netlink_family_ops = {
2083         .family = PF_NETLINK,
2084         .create = netlink_create,
2085         .owner  = THIS_MODULE,  /* for consistency 8) */
2086 };
</code></pre>

<h3>Initialization</h3>

<pre><code class="c">2129 static int __init netlink_proto_init(void)
2130 {
2131         struct sk_buff *dummy_skb;
2132         int i;
2133         unsigned long limit;
2134         unsigned int order;
2135         int err = proto_register(&amp;netlink_proto, 0);
2136
2137         if (err != 0)
2138                 goto out;
2139
2140         BUILD_BUG_ON(sizeof(struct netlink_skb_parms) &gt; sizeof(dummy_skb-&gt;cb));
2141
2142         nl_table = kcalloc(MAX_LINKS, sizeof(*nl_table), GFP_KERNEL);
2143         if (!nl_table)
2144                 goto panic;
2145
2146         if (totalram_pages &gt;= (128 * 1024))
2147                 limit = totalram_pages &gt;&gt; (21 - PAGE_SHIFT);
2148         else
2149                 limit = totalram_pages &gt;&gt; (23 - PAGE_SHIFT);
2150
2151         order = get_bitmask_order(limit) - 1 + PAGE_SHIFT;
2152         limit = (1UL &lt;&lt; order) / sizeof(struct hlist_head);
2153         order = get_bitmask_order(min(limit, (unsigned long)UINT_MAX)) - 1;
2154
2155         for (i = 0; i &lt; MAX_LINKS; i++) {
2156                 struct nl_pid_hash *hash = &amp;nl_table[i].hash;
2157
2158                 hash-&gt;table = nl_pid_hash_zalloc(1 * sizeof(*hash-&gt;table));
2159                 if (!hash-&gt;table) {
2160                         while (i-- &gt; 0)
2161                                 nl_pid_hash_free(nl_table[i].hash.table,
2162                                                  1 * sizeof(*hash-&gt;table));
2163                         kfree(nl_table);
2164                         goto panic;
2165                 }
2166                 hash-&gt;max_shift = order;
2167                 hash-&gt;shift = 0;
2168                 hash-&gt;mask = 0;
2169                 hash-&gt;rehash_time = jiffies;
2170         }
2171
2172         netlink_add_usersock_entry();
2173
2174         sock_register(&amp;netlink_family_ops);
2175         register_pernet_subsys(&amp;netlink_net_ops);
2176         /* The netlink device handler may be needed early. */
2177         rtnetlink_init();
2178 out:
2179         return err;
2180 panic:
2181         panic("netlink_init: Cannot allocate nl_table\n");
2182 }
2183
2184 core_initcall(netlink_proto_init);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netlink Grab]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/03/11/netlink-grab/"/>
    <updated>2013-03-11T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/03/11/netlink-grab</id>
    <content type="html"><![CDATA[<p>å¯¹<code>nl_table</code>çæä½ï¼  <br/>
è¯»æä½: <code>netlink_lock_table</code> å <code>netlink_unlock_table</code> <br/>
åæä½<code>netlink_table_grab</code> å <code>netlink_table_ungrab</code></p>

<p>åå­åé<code>nl_table_users</code> ç¨æ¥ä¿å­å¯¹<code>nl_table</code>çè¯»èå¼ç¨è®¡æ°ã</p>

<p>åªè¦æ²¡æè¿è¡çåèï¼å³ä½¿ænä¸ªåèå¨ç­å¾ï¼mä¸ªè¯»èä¹å¯ä»¥åæ¶è¯»ã
å½æ²¡æä»»ä½è¯»èæ¶ï¼åçæå¯ä»¥è·å¾æéã
ä¸æ¦ä¸ä¸ªåçè·å¾æéï¼ææçè¯»èååèé½å¾ç­å¾ã</p>

<!-- more -->


<h3><code>nl_table_lock</code></h3>

<p>ä¿è¯äº    <br/>
1. è¯»åä¹é´çäºæ¥ <br/>
2. åèä¹é´çäºæ¥</p>

<h3><code>nl_table_users</code></h3>

<p>è¯»èçå¼ç¨è®¡æ°ã</p>

<p>æè§å¾ç±»æ¯è¯»åéï¼åªæ¯åçå¯ä»¥ç¡ç ã</p>

<h1>data struct</h1>

<p>134 static DECLARE_WAIT_QUEUE_HEAD(nl_table_wait);
138 static DEFINE_RWLOCK(nl_table_lock);
139 static atomic_t nl_table_users = ATOMIC_INIT(0);</p>

<h4>è¯»æä½ä¸éï¼</h4>

<ol type="a">
<li>è·åé<code>nl_table_lock</code>çè¯»æéï¼</li>
<li>è®¿é®æ°å¢å 1.</li>
<li>éæ¾è¯»éã</li>
</ol>


<p> 229 static inline void
 230 netlink_lock_table(void)
 231 {     <br/>
 232         /<em> read_lock() synchronizes us to netlink_table_grab </em>/
 233<br/>
 234         read_lock(&amp;nl_table_lock);
 235         atomic_inc(&amp;nl_table_users);
 236         read_unlock(&amp;nl_table_lock);
 237 }</p>

<h4>è¯»æä½å¼éï¼</h4>

<p> nl_table_usersåä¸ï¼
 å¤æ­nl_table_users == 0ï¼
 YES, nl_table_usersä¸º0ï¼è¡¨ç¤ºæ²¡æè¯»è, è°ç¨wakeupå¤éç­å¾çåæä½ã
 NO, &ndash;return.</p>

<p> 239 static inline void
 240 netlink_unlock_table(void)
 241 {
 242         if (atomic_dec_and_test(&amp;nl_table_users))
 243                 wake_up(&amp;nl_table_wait);
 244 }</p>

<h4>åæä½ä¸é:</h4>

<p>1.èåæä½é¦åè·åé<code>nl_table_lock</code>çåæéï¼
å¦æå½åç¨æ·ä¸ªæ°ä¸º0ï¼
ï¼å¹¸è¿åï¼é£ä¹åç»­çæææä½ï¼è¯»åå)é½è¢«é»å¡.å ä¸º<code>nl_table_lock</code>è¢«éä¸äºã</p>

<p>å¦æç¨æ·æ°ä¸ä¸ºé¶ï¼é£ä¹å­å¨nl_table_usersä¸ªè¯»èåmï¼m>=0)ä¸ªç­å¾çåçã
åå»ºä¸ä¸ªç­å¾éåï¼ç­å¾å¶ä»çè¯»æèåçå®æï¼åæ¶èªå·±éè¿scheduleæ¾å¼cpuã</p>

<p>åæ¬¡å¾å°è°åº¦æ¶ï¼é¦åè·ååé<code>nl_table_lock</code>ï¼éå¤ä¸ä¸æ­¥çå¤æ­ã
<a href="https://gist.github.com/martinbj2008/b878b0a3d55533e7073f">netlink_table_grab</a></p>

<h4>åæä½å¼éï¼</h4>

<p>éæ¾åéã
å¤éç­å¾éåã
 222 void netlink_table_ungrab(void)
 223         __releases(nl_table_lock)
 224 {
 225         write_unlock_irq(&amp;nl_table_lock);      <br/>
 226         wake_up(&amp;nl_table_wait);
 227 }</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netlink Bulk Dump]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/03/07/netlink-bulk-dump/"/>
    <updated>2013-03-07T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/03/07/netlink-bulk-dump</id>
    <content type="html"><![CDATA[<pre><code class="c"> 93 struct netlink_callback {
 94         struct sk_buff          *skb;
 95         const struct nlmsghdr   *nlh;
 96         int                     (*dump)(struct sk_buff * skb,
 97                                         struct netlink_callback *cb);
 98         int                     (*done)(struct netlink_callback *cb);
 99         void                    *data;
100         /* the module that dump function belong to */
101         struct module           *module;
102         u16                     family;
103         u16                     min_dump_alloc;
104         unsigned int            prev_seq, seq;
105         long                    args[6];
106 };
</code></pre>

<pre><code class="c">117 struct netlink_dump_control {
118         int (*dump)(struct sk_buff *skb, struct netlink_callback *);
119         int (*done)(struct netlink_callback *);
120         void *data;
121         struct module *module;
122         u16 min_dump_alloc;
123 };
</code></pre>

<p>ææ¶åæä»¬éè¦ä»åæ ¸è¾åºå¤§éçæ¶æ¯ã ä¾å¦ï¼dump interface, xfrm sa,spï¼å åçè³å ä¸æ¡ï¼ç­ è¿äºä¿¡æ¯æ¾ç¶æ æ³æ¾å°ä¸ä¸ªskbéã</p>

<p>è¿æ¯æä»¬éè¦åå©netlinkcallbackæºå¶ã åçï¼ 1.é¦åè¢«dumpçæ°æ®è¦æ¯æä¸¤ä¸ªå½æ° a. dump: æ¯æ¬¡è¾åºæ¶è°ç¨ï¼æ¥çä¸æ¬¡çæ°æ®è¾åºãå¦æå¨é¨è¾åºå®æè¿å0. b. done: å¨é¨è¾åºå®æåè¢«è°ç¨ã</p>

<p>å½dumpçæ¶æ¯éå¸¸å¤æ¶åï¼é¦ååå»ºstruct netlink_callback, å¹¶åå»ºè¿ä¸ªcbæå°netlink socket(nlk)ä¸ã æ­¤å¤çnlkæ¯æåºdumpè¯·æ±çé£ä¸ªsocketã è°ç¨dumpå½æ°è¾åºç¬¬ä¸æ¬¡ç»æï¼ å¹¶å°ç»ææ¾å°æ¾å°nlkçæ¥åéåéï¼æ¿ådatareadyã</p>

<p>å æ­¤åºç¨ç¨åºè¿æ¶rcvmsgå°±ä¼è¿åãå¹¶å¾å°ç¬¬ä¸æ¬¡çè¾åºç»æï¼ å¨rcvmsgçç³»ç»è°ç¨åæ¬¡netlink_dumpã</p>

<p>è¿æ ·åºç¨ç¨åºæ¯æ¬¡éè¿ç³»ç»è°ç¨rcv, å¨å°æ°æ®ä»åæ ¸ä¸­æ¶ä¸æ¥çï¼ åæ¶ï¼è¿ä¸ªç³»ç»è°ç¨rcvä¹æ¿åçä¸æ¬¡netlink_dump,æ°çæ°æ®è¢« è¿½å å°äºsocketçæ¥åéåéã ç´å°ææçæ°æ®dumpå®æï¼cb->dump(skb, cb);è¿å0 ï¼è§line1747 in netlink_dump) åæ ¸è°ç¨ cb->done(cb), å¹¶å°cbä»netlink socketä¸å é¤å¹¶éæ¾å¯¹åºçåå­ã nlk->cb = NULL; netlink_consume_callback(cb);</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netlink in Kernel]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/02/16/netlink-in-kernel/"/>
    <updated>2013-02-16T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/02/16/netlink-in-kernel</id>
    <content type="html"><![CDATA[<h1>netlink socket framework.</h1>

<h2>netlink socket proto</h2>

<p>  netlink socket is a kind of socket. There are many proto of netlink. There may have many groups under each proto. See example in following.</p>

<p>Every netlink socket is indicated by <code>&lt;net, proto, pid&gt;</code>.</p>

<ol>
<li>net: the net namespace.</li>
<li>proto: netlink proto.</li>
<li>pid:</li>
</ol>


<!-- more -->


<pre><code class="c">  7 #define NETLINK_ROUTE           0       /* Routing/device hook                          */
  8 #define NETLINK_UNUSED          1       /* Unused number                                */
  9 #define NETLINK_USERSOCK        2       /* Reserved for user mode socket protocols      */
 10 #define NETLINK_FIREWALL        3       /* Firewalling hook                             */
 11 #define NETLINK_SOCK_DIAG       4       /* socket monitoring                            */
 12 #define NETLINK_NFLOG           5       /* netfilter/iptables ULOG */
 13 #define NETLINK_XFRM            6       /* ipsec */
 14 #define NETLINK_SELINUX         7       /* SELinux event notifications */
 15 #define NETLINK_ISCSI           8       /* Open-iSCSI */
 16 #define NETLINK_AUDIT           9       /* auditing */
 17 #define NETLINK_FIB_LOOKUP      10
 18 #define NETLINK_CONNECTOR       11
 19 #define NETLINK_NETFILTER       12      /* netfilter subsystem */
 20 #define NETLINK_IP6_FW          13
 21 #define NETLINK_DNRTMSG         14      /* DECnet routing messages */
 22 #define NETLINK_KOBJECT_UEVENT  15      /* Kernel messages to userspace */
 23 #define NETLINK_GENERIC         16
 24 /* leave room for NETLINK_DM (DM Events) */
 25 #define NETLINK_SCSITRANSPORT   18      /* SCSI Transports */
 26 #define NETLINK_ECRYPTFS        19
 27 #define NETLINK_RDMA            20
 28 #define NETLINK_CRYPTO          21      /* Crypto layer */
 29
 30 #define NETLINK_INET_DIAG       NETLINK_SOCK_DIAG
 31
 32 #define MAX_LINKS 32
</code></pre>

<p>Each proto of netlink has many groups, for example xfrm netlink:
<code>c
462 enum xfrm_nlgroups {
463         XFRMNLGRP_NONE,
464 #define XFRMNLGRP_NONE          XFRMNLGRP_NONE
465         XFRMNLGRP_ACQUIRE,
466 #define XFRMNLGRP_ACQUIRE       XFRMNLGRP_ACQUIRE
467         XFRMNLGRP_EXPIRE,
468 #define XFRMNLGRP_EXPIRE        XFRMNLGRP_EXPIRE
469         XFRMNLGRP_SA,
470 #define XFRMNLGRP_SA            XFRMNLGRP_SA
471         XFRMNLGRP_POLICY,
472 #define XFRMNLGRP_POLICY        XFRMNLGRP_POLICY
473         XFRMNLGRP_AEVENTS,
474 #define XFRMNLGRP_AEVENTS       XFRMNLGRP_AEVENTS
475         XFRMNLGRP_REPORT,
476 #define XFRMNLGRP_REPORT        XFRMNLGRP_REPORT
477         XFRMNLGRP_MIGRATE,
478 #define XFRMNLGRP_MIGRATE       XFRMNLGRP_MIGRATE
479         XFRMNLGRP_MAPPING,
480 #define XFRMNLGRP_MAPPING       XFRMNLGRP_MAPPING
481         __XFRMNLGRP_MAX
482 };
483 #define XFRMNLGRP_MAX   (__XFRMNLGRP_MAX - 1)
</code>
all the supported protos are stored in the array <code>nl_table</code>.</p>

<p><code>static struct netlink_table *nl_table</code>;</p>

<p>each type is stored in a struct netlink_table
<code>c
119 struct netlink_table {
120         struct nl_pid_hash hash;          /* store all the netlink socket with hash list */
121         struct hlist_head mc_list;            /* store all the netlink socket listen broadcast netlink message */
122         struct listeners __rcu *listeners;      /* store with a bit(1) for each netlink broadcast type, which is listened by one or more netlink sockets in mc_list(line 121) */
123         unsigned int nl_nonroot;
124         unsigned int groups;            /* the counts of bits in listeners(line 122)*/
125         struct mutex *cb_mutex;
126         struct module *module;
127         int registered;             /* avoid repeated register. */
128 };
</code>
In initialization, each type netlink call netlink_kernel_create, which will prepare two parts:</p>

<ol>
<li>Register in a netlink_table of nl_table,</li>
<li>Create a netlink kernel socket for the registered proto.</li>
</ol>


<h2>Example: xfrm netlink</h2>

<p>  Register a netlink type with NETLINK_XFRM, which has XFRMNLGRP_MAX groups. and all the netlink message will be processed by xfrm_netlink_rcv.
<code>c
2603 static int __net_init xfrm_user_net_init(struct net *net)
2604 {
2605         struct sock *nlsk;
2606
2607         nlsk = netlink_kernel_create(net, NETLINK_XFRM, XFRMNLGRP_MAX,
2608                                      xfrm_netlink_rcv, NULL, THIS_MODULE);
2609         if (nlsk == NULL)
2610                 return -ENOMEM;
2611         rcu_assign_pointer(net-&gt;xfrm.nlsk, nlsk);
2612         return 0;
2613 }
</code></p>

<h3>Data struct &amp;&amp; method</h3>

<h4>struct netlink_sock</h4>

<pre><code class="c">67 struct netlink_sock {
68         /* struct sock has to be the first member of netlink_sock */
69         struct sock             sk;
70         u32                     pid;
71         u32                     dst_pid;
72         u32                     dst_group;
73         u32                     flags;
74         u32                     subscriptions;
75         u32                     ngroups;
76         unsigned long           *groups;
77         unsigned long           state;
78         wait_queue_head_t       wait;
79         struct netlink_callback *cb;
80         struct mutex            *cb_mutex;
81         struct mutex            cb_def_mutex;
82         void                    (*netlink_rcv)(struct sk_buff *skb);
83         struct module           *module;
84 };
</code></pre>

<p>Every netlink socket has a pid. The pid of netlink kernel sockets is 0. All the the netlink message need kernel process, will be sent to them. (net, pid, protocol) will be used to locate the destination of a netlink message.</p>

<h4>netlink_create</h4>

<pre><code class="c"> 430 static int netlink_create(struct net *net, struct socket *sock, int protocol,
 431                           int kern)
 432 {
 433         struct module *module = NULL;
 434         struct mutex *cb_mutex;
 435         struct netlink_sock *nlk;
 436         int err = 0;
 437
 438         sock-&gt;state = SS_UNCONNECTED;
 439
 440         if (sock-&gt;type != SOCK_RAW &amp;&amp; sock-&gt;type != SOCK_DGRAM)
 441                 return -ESOCKTNOSUPPORT;
 442
 443         if (protocol &lt; 0 || protocol &gt;= MAX_LINKS)
 444                 return -EPROTONOSUPPORT;
 445
 446         netlink_lock_table();
 447 #ifdef CONFIG_MODULES
 448         if (!nl_table[protocol].registered) {
 449                 netlink_unlock_table();
 450                 request_module("net-pf-%d-proto-%d", PF_NETLINK, protocol);
 451                 netlink_lock_table();
 452         }
 453 #endif
 454         if (nl_table[protocol].registered &amp;&amp;
 455             try_module_get(nl_table[protocol].module))
 456                 module = nl_table[protocol].module;
 457         else
 458                 err = -EPROTONOSUPPORT;
 459         cb_mutex = nl_table[protocol].cb_mutex;
 460         netlink_unlock_table();
 461
 462         if (err &lt; 0)
 463                 goto out;
 464
 465         err = __netlink_create(net, sock, cb_mutex, protocol);
 466         if (err &lt; 0)
 467                 goto out_module;
 468
 469         local_bh_disable();
 470         sock_prot_inuse_add(net, &amp;netlink_proto, 1);
 471         local_bh_enable();
 472
 473         nlk = nlk_sk(sock-&gt;sk);
 474         nlk-&gt;module = module;
 475 out:
 476         return err;
 477
 478 out_module:
 479         module_put(module);
 480         goto out;
 481 }
</code></pre>

<pre><code class="c">402 static int __netlink_create(struct net *net, struct socket *sock,
403                             struct mutex *cb_mutex, int protocol)
404 {
405         struct sock *sk;
406         struct netlink_sock *nlk;
407
408         sock-&gt;ops = &amp;netlink_ops;
409
410         sk = sk_alloc(net, PF_NETLINK, GFP_KERNEL, &amp;netlink_proto);
411         if (!sk)
412                 return -ENOMEM;
413
414         sock_init_data(sock, sk);
415
416         nlk = nlk_sk(sk);
417         if (cb_mutex)
418                 nlk-&gt;cb_mutex = cb_mutex;
419         else {
420                 nlk-&gt;cb_mutex = &amp;nlk-&gt;cb_def_mutex;
421                 mutex_init(nlk-&gt;cb_mutex);
422         }
423         init_waitqueue_head(&amp;nlk-&gt;wait);
424
425         sk-&gt;sk_destruct = netlink_sock_destruct;
426         sk-&gt;sk_protocol = protocol;
427         return 0;
428 }
</code></pre>

<h4>netlink_sendmsg</h4>

<pre><code>netlink_sendmsg ââ&gt; netlink_unicastg ââ&gt; nlk-&gt;netlink_rcv,
</code></pre>

<p>Create a skb and init <code>NETLINK_CB(skb)</code>, Copy the message data with memcpy_fromiovec.</p>

<p>If its destination is a group, then broadcast it with netlink_broadcast, or it is a unicast message, send it by netlink_unicast.</p>

<p><code>nlk-&gt;netlink_rcv</code> is set in <code>netlink_create</code> for xfrm netlink message, it is<code>xfrm_netlink_rcv</code>.
<code>c
1313 static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
1314                            struct msghdr *msg, size_t len)
1315 {
1316         struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
1317         struct sock *sk = sock-&gt;sk;
1318         struct netlink_sock *nlk = nlk_sk(sk);
1319         struct sockaddr_nl *addr = msg-&gt;msg_name;
1320         u32 dst_pid;
1321         u32 dst_group;
1322         struct sk_buff *skb;
1323         int err;
1324         struct scm_cookie scm;
1325
1326         if (msg-&gt;msg_flags&amp;MSG_OOB)
1327                 return -EOPNOTSUPP;
1328
1329         if (NULL == siocb-&gt;scm)
1330                 siocb-&gt;scm = &amp;scm;
1331
1332         err = scm_send(sock, msg, siocb-&gt;scm, true);
1333         if (err &lt; 0)
1334                 return err;
1335
1336         if (msg-&gt;msg_namelen) {
1337                 err = -EINVAL;
1338                 if (addr-&gt;nl_family != AF_NETLINK)
1339                         goto out;
1340                 dst_pid = addr-&gt;nl_pid;
1341                 dst_group = ffs(addr-&gt;nl_groups);
1342                 err =  -EPERM;
1343                 if ((dst_group || dst_pid) &amp;&amp;
1344                     !netlink_capable(sock, NL_NONROOT_SEND))
1345                         goto out;
1346         } else {
1347                 dst_pid = nlk-&gt;dst_pid;
1348                 dst_group = nlk-&gt;dst_group;
1349         }
1350
1351         if (!nlk-&gt;pid) {
1352                 err = netlink_autobind(sock);
1353                 if (err)
1354                         goto out;
1355         }
1356
1357         err = -EMSGSIZE;
1358         if (len &gt; sk-&gt;sk_sndbuf - 32)
1359                 goto out;
1360         err = -ENOBUFS;
1361         skb = alloc_skb(len, GFP_KERNEL);
1362         if (skb == NULL)
1363                 goto out;
1364
1365         NETLINK_CB(skb).pid     = nlk-&gt;pid;
1366         NETLINK_CB(skb).dst_group = dst_group;
1367         memcpy(NETLINK_CREDS(skb), &amp;siocb-&gt;scm-&gt;creds, sizeof(struct ucred));
1368
1369         err = -EFAULT;
1370         if (memcpy_fromiovec(skb_put(skb, len), msg-&gt;msg_iov, len)) {
1371                 kfree_skb(skb);
1372                 goto out;
1373         }
1374
1375         err = security_netlink_send(sk, skb);
1376         if (err) {
1377                 kfree_skb(skb);
1378                 goto out;
1379         }
1380
1381         if (dst_group) {
1382                 atomic_inc(&amp;skb-&gt;users);
1383                 netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
1384         }
1385         err = netlink_unicast(sk, skb, dst_pid, msg-&gt;msg_flags&amp;MSG_DONTWAIT);
1386
1387 out:
1388         scm_destroy(siocb-&gt;scm);
1389         return err;
1390 }
</code></p>

<h3>netlink_unicast</h3>

<p>  find the dest netlink socket by its pid.
if dst socket is a kernl socket, call netlink_unicast_kernel. for example : in the case, dump xfrm sa. else put the skb into the dest socket recv queue.</p>

<pre><code class="c">891 int netlink_unicast(struct sock ssk, struct sk_buff skb, 
892 u32 pid, int nonblock)
893 { 
894 struct sock *sk; 
895 int err; 
896 long timeo; 
897 
898 skb = netlink_trim(skb, gfp_any()); 
899 
900 timeo = sock_sndtimeo(ssk, nonblock); 
901 retry: 
902 sk = netlink_getsockbypid(ssk, pid); 
903 if (IS_ERR(sk)) { 
904 kfree_skb(skb); 
905 return PTR_ERR(sk); 
906 } 
907 if (netlink_is_kernel(sk)) 
908 return netlink_unicast_kernel(sk, skb); 
909 
910 if (sk_filter(sk, skb)) { 
911 err = skb-&gt;len; 
912 kfree_skb(skb); 
913 sock_put(sk); 
914 return err; 
915 } 
916 
917 err = netlink_attachskb(sk, skb, &amp;timeo, ssk); 
918 if (err == 1) 
919 goto retry; 
920 if (err) 
921 return err; 
922 
923 return netlink_sendskb(sk, skb); 
924 } 
925 EXPORT_SYMBOL(netlink_unicast);
</code></pre>

<h3>broadcast message</h3>

<pre><code class="c"> 905 int netlink_unicast(struct sock *ssk, struct sk_buff *skb,
 906                     u32 pid, int nonblock)
 907 {
 908         struct sock *sk;
 909         int err;
 910         long timeo;
 911
 912         skb = netlink_trim(skb, gfp_any());
 913
 914         timeo = sock_sndtimeo(ssk, nonblock);
 915 retry:
 916         sk = netlink_getsockbypid(ssk, pid);
 917         if (IS_ERR(sk)) {
 918                 kfree_skb(skb);
 919                 return PTR_ERR(sk);
 920         }
 921         if (netlink_is_kernel(sk))
 922                 return netlink_unicast_kernel(sk, skb);
 923
 924         if (sk_filter(sk, skb)) {
 925                 err = skb-&gt;len;
 926                 kfree_skb(skb);
 927                 sock_put(sk);
 928                 return err;
 929         }
 930
 931         err = netlink_attachskb(sk, skb, &amp;timeo, ssk);
 932         if (err == 1)
 933                 goto retry;
 934         if (err)
 935                 return err;
 936
 937         return netlink_sendskb(sk, skb);
 938 }
</code></pre>

<pre><code class="c"> 889 static int netlink_unicast_kernel(struct sock *sk, struct sk_buff *skb)
 890 {
 891         int ret;
 892         struct netlink_sock *nlk = nlk_sk(sk);
 893
 894         ret = -ECONNREFUSED;
 895         if (nlk-&gt;netlink_rcv != NULL) {
 896                 ret = skb-&gt;len;
 897                 skb_set_owner_r(skb, sk);
 898                 nlk-&gt;netlink_rcv(skb);
 899         }
 900         kfree_skb(skb);
 901         sock_put(sk);
 902         return ret;
 903 }
</code></pre>

<pre><code class="c">  86 struct listeners {
  87         struct rcu_head         rcu;
  88         unsigned long           masks[0];
  89 };
</code></pre>

<pre><code class="c">106 struct nl_pid_hash {
 107         struct hlist_head *table;
 108         unsigned long rehash_time;
 109
 110         unsigned int mask;
 111         unsigned int shift;
 112
 113         unsigned int entries;
 114         unsigned int max_shift;
 115
 116         u32 rnd;
 117 };
</code></pre>

<pre><code class="c">  55 struct rtnl_link {
  56         rtnl_doit_func          doit;
  57         rtnl_dumpit_func        dumpit;
  58         rtnl_calcit_func        calcit;
  59 };
</code></pre>

<pre><code>101 static struct rtnl_link *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];
</code></pre>

<h3>pernet ops</h3>

<pre><code>2124 static struct pernet_operations __net_initdata netlink_net_ops = {
2125         .init = netlink_net_init,
2126         .exit = netlink_net_exit,
2127 };
</code></pre>

<h3>socket related ops</h3>

<pre><code> 396 static struct proto netlink_proto = {
 397         .name     = "NETLINK",
 398         .owner    = THIS_MODULE,
 399         .obj_size = sizeof(struct netlink_sock),
 400 };
</code></pre>

<pre><code>2061 static const struct proto_ops netlink_ops = {
2062         .family =       PF_NETLINK,
2063         .owner =        THIS_MODULE,
2064         .release =      netlink_release,
2065         .bind =         netlink_bind,
2066         .connect =      netlink_connect,
2067         .socketpair =   sock_no_socketpair,
2068         .accept =       sock_no_accept,
2069         .getname =      netlink_getname,
2070         .poll =         datagram_poll,
2071         .ioctl =        sock_no_ioctl,
2072         .listen =       sock_no_listen,
2073         .shutdown =     sock_no_shutdown,
2074         .setsockopt =   netlink_setsockopt,
2075         .getsockopt =   netlink_getsockopt,
2076         .sendmsg =      netlink_sendmsg,
2077         .recvmsg =      netlink_recvmsg,
2078         .mmap =         sock_no_mmap,
2079         .sendpage =     sock_no_sendpage,
2080 };
</code></pre>

<pre><code>2082 static const struct net_proto_family netlink_family_ops = {
2083         .family = PF_NETLINK,
2084         .create = netlink_create,
2085         .owner  = THIS_MODULE,  /* for consistency 8) */
2086 };
</code></pre>

<h3>Initialization</h3>

<pre><code class="c">2129 static int __init netlink_proto_init(void)
2130 {
2131         struct sk_buff *dummy_skb;
2132         int i;
2133         unsigned long limit;
2134         unsigned int order;
2135         int err = proto_register(&amp;netlink_proto, 0);
2136
2137         if (err != 0)
2138                 goto out;
2139
2140         BUILD_BUG_ON(sizeof(struct netlink_skb_parms) &gt; sizeof(dummy_skb-&gt;cb));
2141
2142         nl_table = kcalloc(MAX_LINKS, sizeof(*nl_table), GFP_KERNEL);
2143         if (!nl_table)
2144                 goto panic;
2145
2146         if (totalram_pages &gt;= (128 * 1024))
2147                 limit = totalram_pages &gt;&gt; (21 - PAGE_SHIFT);
2148         else
2149                 limit = totalram_pages &gt;&gt; (23 - PAGE_SHIFT);
2150
2151         order = get_bitmask_order(limit) - 1 + PAGE_SHIFT;
2152         limit = (1UL &lt;&lt; order) / sizeof(struct hlist_head);
2153         order = get_bitmask_order(min(limit, (unsigned long)UINT_MAX)) - 1;
2154
2155         for (i = 0; i &lt; MAX_LINKS; i++) {
2156                 struct nl_pid_hash *hash = &amp;nl_table[i].hash;
2157
2158                 hash-&gt;table = nl_pid_hash_zalloc(1 * sizeof(*hash-&gt;table));
2159                 if (!hash-&gt;table) {
2160                         while (i-- &gt; 0)
2161                                 nl_pid_hash_free(nl_table[i].hash.table,
2162                                                  1 * sizeof(*hash-&gt;table));
2163                         kfree(nl_table);
2164                         goto panic;
2165                 }
2166                 hash-&gt;max_shift = order;
2167                 hash-&gt;shift = 0;
2168                 hash-&gt;mask = 0;
2169                 hash-&gt;rehash_time = jiffies;
2170         }
2171
2172         netlink_add_usersock_entry();
2173
2174         sock_register(&amp;netlink_family_ops);
2175         register_pernet_subsys(&amp;netlink_net_ops);
2176         /* The netlink device handler may be needed early. */
2177         rtnetlink_init();
2178 out:
2179         return err;
2180 panic:
2181         panic("netlink_init: Cannot allocate nl_table\n");
2182 }
2183
2184 core_initcall(netlink_proto_init);
</code></pre>
]]></content>
  </entry>
  
</feed>
