<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Socket | My Octopress Blog]]></title>
  <link href="http://martinbj2008.github.io/blog/categories/socket/atom.xml" rel="self"/>
  <link href="http://martinbj2008.github.io/"/>
  <updated>2015-05-21T16:26:25+08:00</updated>
  <id>http://martinbj2008.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Select Source Ip for a Tcp Socket]]></title>
    <link href="http://martinbj2008.github.io/blog/2014/07/31/how-to-select-source-ip-for-a-tcp-socket/"/>
    <updated>2014-07-31T09:06:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2014/07/31/how-to-select-source-ip-for-a-tcp-socket</id>
    <content type="html"><![CDATA[<h1>#</h1>

<p>This question should be divided into two parts.</p>

<h3>Part 1: adding a route</h3>

<h4>Add a direct(link) route</h4>

<h4>Add a route with gateway</h4>

<h3>create a socket</h3>

<h4>for example &lsquo;connect&rsquo; system call</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Remember Ip/tcp/udp Header]]></title>
    <link href="http://martinbj2008.github.io/blog/2014/01/27/how-to-remember-ip-slash-tcp-slash-udp-header/"/>
    <updated>2014-01-27T14:25:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2014/01/27/how-to-remember-ip-slash-tcp-slash-udp-header</id>
    <content type="html"><![CDATA[<h3>IP HEADER</h3>

<p>以前找工作时，常被问到IP头都有哪些字段？
现在觉得真的理解了记起来没那么难。</p>

<p>上路时总要记得终点和起点(src/dst ip),
要倒几次车，大体也知道（ttl).</p>

<p>路有大路有小路，有高速路和土路。
大路到小路要分片，小路到大路可能重组。
上高速路需要通行证（qos/tos).</p>

<p>路上有警察，查你是不是非法(csum, header len, ip option)，
查你装的什么货(protocol)？</p>

<!-- more -->


<ol>
<li>路由：要做路由，IP地址是必须的, 如何防止循环链路？
  源/目的IP地址，ttl</li>
<li>分片与重组：ID, 总长度，片的偏移，标志位,
 ID, total length, offset, E/D/M flags</li>
<li>QOS:  TOS</li>
<li>校验：checksum</li>
<li>上层协议：proto
<img src="/images/net/ip.header.png" alt="case 1" />

<h3>TCP HEADER</h3>

<img src="/images/net/tcp.header.png" alt="case 1" />

<h3>UDP HEADER</h3>

<img src="/images/net/udp.header.png" alt="case 1" />

<h3>ICMP HEADER</h3>

<p><img src="/images/net/icmp.header.png" alt="case 1" /></p></li>
</ol>


<p>NOTE: all the pictures are &lsquo;stolen&rsquo; from
<code>http://nmap.org/book/tcpip-ref.html</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Tcp Server Accept a New Connection Request]]></title>
    <link href="http://martinbj2008.github.io/blog/2014/01/14/how-tcp-server-accept-a-new-connection-request/"/>
    <updated>2014-01-14T16:01:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2014/01/14/how-tcp-server-accept-a-new-connection-request</id>
    <content type="html"><![CDATA[<p>Two packets will be proessed by tcp server side:
1. SYN
2. ACK</p>

<p>For the first packet(syn) of handshake, it first lookup the listen socket,
and create a req socket as temporary.</p>

<p>For the third packet(ack) of handshake, it will match the req socket created
in previous steps.</p>

<!-- more -->


<p>SYN:<br/>
<code>c
== tcp_v4_rcv(struct sk_buff *skb)
== ==  sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);
== ==  tcp_v4_do_rcv(sk, skb);
== == == struct sock *nsk = tcp_v4_hnd_req(sk, skb)
== == == tcp_rcv_state_process
== == == == if (icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; 0)
== == == == tcp_v4_conn_request: icsk-&gt;icsk_af_ops-&gt;conn_request
== == == == == inet_reqsk_alloc
== == == == == tcp_openreq_init(req, &amp;tmp_opt, skb);
== == == == == inet_csk_reqsk_queue_hash_add
== == == == == == reqsk_queue_hash_req
== == == == == == inet_csk_reqsk_queue_added
</code></p>

<p>ACK:</p>

<h3><code>tcp_rcv_state_process</code> use a child socket, not the listen socket.</h3>

<p>The new socket state is <code>TCP_SYN_RECV</code></p>

<pre><code class="c">== tcp_v4_rcv(struct sk_buff *skb)
== ==  sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest); 
== == tcp_v4_do_rcv(sk, skb);
== == == nsk = tcp_v4_hnd_req(sk, skb)
== == == == inet_csk_search_req
== == == == tcp_check_req
== == == == == child = inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock(sk, skb, req, NULL);
== == == == == inet_csk_reqsk_queue_unlink(sk, req, prev);
== == == == == inet_csk_reqsk_queue_removed(sk, req);
== == == == == inet_csk_reqsk_queue_add(sk, req, child);
== == == tcp_child_process(sk, nsk, skb)
== == == ==  tcp_rcv_state_process(child, skb, tcp_hdr(skb),...i
== == == == TCP_SYN_RECV: tcp_rcv_synsent_state_process
</code></pre>

<h3><code>tcp_v4_rcv</code></h3>

<pre><code class="c">1936 int tcp_v4_rcv(struct sk_buff *skb)
1937 {
1938         const struct iphdr *iph;
1939         const struct tcphdr *th;
1940         struct sock *sk;
1941         int ret;
1942         struct net *net = dev_net(skb-&gt;dev);
1943
1944         if (skb-&gt;pkt_type != PACKET_HOST)
1945                 goto discard_it;
1946
1947         /* Count it even if it's bad */
1948         TCP_INC_STATS_BH(net, TCP_MIB_INSEGS);
1949
1950         if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
1951                 goto discard_it;
1952
1953         th = tcp_hdr(skb);
1954
1955         if (th-&gt;doff &lt; sizeof(struct tcphdr) / 4)
1956                 goto bad_packet;
1957         if (!pskb_may_pull(skb, th-&gt;doff * 4))
1958                 goto discard_it;
1959
1960         /* An explanation is required here, I think.
1961          * Packet length and doff are validated by header prediction,
1962          * provided case of th-&gt;doff==0 is eliminated.
1963          * So, we defer the checks. */
1964         if (!skb_csum_unnecessary(skb) &amp;&amp; tcp_v4_checksum_init(skb))
1965                 goto csum_error;
1966
1967         th = tcp_hdr(skb);
1968         iph = ip_hdr(skb);
1969         TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);
1970         TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin +
1971                                     skb-&gt;len - th-&gt;doff * 4);
1972         TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);
1973         TCP_SKB_CB(skb)-&gt;when    = 0;
1974         TCP_SKB_CB(skb)-&gt;ip_dsfield = ipv4_get_dsfield(iph);
1975         TCP_SKB_CB(skb)-&gt;sacked  = 0;
1976
1977         sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);
1978         if (!sk)
1979                 goto no_tcp_socket;
1980
1981 process:
1982         if (sk-&gt;sk_state == TCP_TIME_WAIT)
1983                 goto do_time_wait;
1984
1985         if (unlikely(iph-&gt;ttl &lt; inet_sk(sk)-&gt;min_ttl)) {
1986                 NET_INC_STATS_BH(net, LINUX_MIB_TCPMINTTLDROP);
1987                 goto discard_and_relse;
1988         }
1989
1990         if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
1991                 goto discard_and_relse;
1992         nf_reset(skb);
1993
1994         if (sk_filter(sk, skb))
1995                 goto discard_and_relse;
1996
1997         sk_mark_napi_id(sk, skb);
1998         skb-&gt;dev = NULL;
1999
2000         bh_lock_sock_nested(sk);
2001         ret = 0;
2002         if (!sock_owned_by_user(sk)) {
2003 #ifdef CONFIG_NET_DMA
2004                 struct tcp_sock *tp = tcp_sk(sk);
2005                 if (!tp-&gt;ucopy.dma_chan &amp;&amp; tp-&gt;ucopy.pinned_list)
2006                         tp-&gt;ucopy.dma_chan = net_dma_find_channel();
2007                 if (tp-&gt;ucopy.dma_chan)
2008                         ret = tcp_v4_do_rcv(sk, skb);
2009                 else
2010 #endif
2011                 {
2012                         if (!tcp_prequeue(sk, skb))
2013                                 ret = tcp_v4_do_rcv(sk, skb);
2014                 }
2015         } else if (unlikely(sk_add_backlog(sk, skb,
2016                                            sk-&gt;sk_rcvbuf + sk-&gt;sk_sndbuf))) {
2017                 bh_unlock_sock(sk);
2018                 NET_INC_STATS_BH(net, LINUX_MIB_TCPBACKLOGDROP);
2019                 goto discard_and_relse;
2020         }
2021         bh_unlock_sock(sk);
2022
2023         sock_put(sk);
2024
2025         return ret;
2026
2027 no_tcp_socket:
2028         if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
2029                 goto discard_it;
2030
2031         if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) {
2032 csum_error:
2033                 TCP_INC_STATS_BH(net, TCP_MIB_CSUMERRORS);
2034 bad_packet:
2035                 TCP_INC_STATS_BH(net, TCP_MIB_INERRS);
2036         } else {
2037                 tcp_v4_send_reset(NULL, skb);
2038         }
2039
2040 discard_it:
2041         /* Discard frame. */
2042         kfree_skb(skb);
2043         return 0;
2044
2045 discard_and_relse:
2046         sock_put(sk);
2047         goto discard_it;
2048
2049 do_time_wait:
2050         if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
2051                 inet_twsk_put(inet_twsk(sk));
2052                 goto discard_it;
2053         }
2054
2055         if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2)) {
2056                 inet_twsk_put(inet_twsk(sk));
2057                 goto bad_packet;
2058         }
2059         if (tcp_checksum_complete(skb)) {
2060                 inet_twsk_put(inet_twsk(sk));
2061                 goto csum_error;
2062         }
2063         switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
2064         case TCP_TW_SYN: {
2065                 struct sock *sk2 = inet_lookup_listener(dev_net(skb-&gt;dev),
2066                                                         &amp;tcp_hashinfo,
2067                                                         iph-&gt;saddr, th-&gt;source,
2068                                                         iph-&gt;daddr, th-&gt;dest,
2069                                                         inet_iif(skb));
2070                 if (sk2) {
2071                         inet_twsk_deschedule(inet_twsk(sk), &amp;tcp_death_row);
2072                         inet_twsk_put(inet_twsk(sk));
2073                         sk = sk2;
2074                         goto process;
2075                 }
2076                 /* Fall through to ACK */
2077         }
2078         case TCP_TW_ACK:
2079                 tcp_v4_timewait_ack(sk, skb);
2080                 break;
2081         case TCP_TW_RST:
2082                 goto no_tcp_socket;
2083         case TCP_TW_SUCCESS:;
2084         }
2085         goto discard_it;
2086 }
</code></pre>

<h3><code>tcp_v4_do_rcv</code></h3>

<pre><code class="c">1778 int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)
1779 {
1780         struct sock *rsk;
1781 #ifdef CONFIG_TCP_MD5SIG
1782         /*
1783          * We really want to reject the packet as early as possible
1784          * if:
1785          *  o We're expecting an MD5'd packet and this is no MD5 tcp option
1786          *  o There is an MD5 option and we're not expecting one
1787          */
1788         if (tcp_v4_inbound_md5_hash(sk, skb))
1789                 goto discard;
1790 #endif
1791
1792         if (sk-&gt;sk_state == TCP_ESTABLISHED) { /* Fast path */
1793                 struct dst_entry *dst = sk-&gt;sk_rx_dst;
1794
1795                 sock_rps_save_rxhash(sk, skb);
1796                 if (dst) {
1797                         if (inet_sk(sk)-&gt;rx_dst_ifindex != skb-&gt;skb_iif ||
1798                             dst-&gt;ops-&gt;check(dst, 0) == NULL) {
1799                                 dst_release(dst);
1800                                 sk-&gt;sk_rx_dst = NULL;
1801                         }
1802                 }
1803                 tcp_rcv_established(sk, skb, tcp_hdr(skb), skb-&gt;len);
1804                 return 0;
1805         }
1806
1807         if (skb-&gt;len &lt; tcp_hdrlen(skb) || tcp_checksum_complete(skb))
1808                 goto csum_err;
1809
1810         if (sk-&gt;sk_state == TCP_LISTEN) {
1809
1810         if (sk-&gt;sk_state == TCP_LISTEN) {
1811                 struct sock *nsk = tcp_v4_hnd_req(sk, skb);
1812                 if (!nsk)
1813                         goto discard;
1814
1815                 if (nsk != sk) {
1816                         sock_rps_save_rxhash(nsk, skb);
1817                         if (tcp_child_process(sk, nsk, skb)) {
1818                                 rsk = nsk;
1819                                 goto reset;
1820                         }
1821                         return 0;
1822                 }
1823         } else
1824                 sock_rps_save_rxhash(sk, skb);
1825
1826         if (tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb-&gt;len)) {
1827                 rsk = sk;
1828                 goto reset;
1829         }
1830         return 0;
1831
1832 reset:
1833         tcp_v4_send_reset(rsk, skb);
1834 discard:
1835         kfree_skb(skb);
1836         /* Be careful here. If this function gets more complicated and
1837          * gcc suffers from register pressure on the x86, sk (in %ebx)
1838          * might be destroyed here. This current version compiles correctly,
1839          * but you have been warned.
1840          */
1841         return 0;
1842
1843 csum_err:
1844         TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_CSUMERRORS);
1845         TCP_INC_STATS_BH(sock_net(sk), TCP_MIB_INERRS);
1846         goto discard;
1847 }
1848 EXPORT_SYMBOL(tcp_v4_do_rcv);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How IPV4/6 Process Input Tcp/udp Packet]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/11/25/net-protocol-handler-for-tcp-udp/"/>
    <updated>2013-11-25T10:54:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/11/25/net-protocol-handler-for-tcp-udp</id>
    <content type="html"><![CDATA[<p>For the packet to localhost, <code>ip_local_deliver_finish</code> will be the
last funciton called by network layer.</p>

<p>In <code>ip_local_deliver_finish</code>, it will be process the protocol
hander of a array element of <code>inet_protos</code> according the <code>protocol</code> value
in IPv4 header.</p>

<p>IPv6 is very similar vs IPv4 except the name is a bit different.</p>

<!-- more -->


<h3>Data structure for IPv4</h3>

<h4><code>net_protocol</code></h4>

<pre><code class="c"> 34 /* This is one larger than the largest protocol value that can be
 35  * found in an ipv4 or ipv6 header.  Since in both cases the protocol
 36  * value is presented in a __u8, this is defined to be 256.
 37  */
 38 #define MAX_INET_PROTOS         256
 39 
 40 /* This is used to register protocols. */
 41 struct net_protocol {
 42         void                    (*early_demux)(struct sk_buff *skb);
 43         int                     (*handler)(struct sk_buff *skb);
 44         void                    (*err_handler)(struct sk_buff *skb, u32 info);
 45         unsigned int            no_policy:1,
 46                                 netns_ok:1;
 47 }
</code></pre>

<p>The <code>handler</code> is the main part, it will be called to process upper protol over IPv4.</p>

<p>Fox example: tcpv4 will be <code>tcp_v4_rcv</code>.
<code>
1540 static const struct net_protocol tcp_protocol = {
1541         .early_demux    =       tcp_v4_early_demux,
1542         .handler        =       tcp_v4_rcv,
1543         .err_handler    =       tcp_v4_err,
1544         .no_policy      =       1,
1545         .netns_ok       =       1,
1546 };
</code></p>

<h4>pointer array for all protocols</h4>

<p>There is a pointer array <code>inet_protos</code> to collect all the supported protocols by IPv4.
<code>
 31 const struct net_protocol __rcu *inet_protos[MAX_INET_PROTOS] __read_mostly;
 32 const struct net_offload __rcu *inet_offloads[MAX_INET_PROTOS] __read_mostly;
</code></p>

<p>The &lsquo;ADD&rsquo; and &lsquo;DEL" operation is done by <code>inet_add_protocol</code> and <code>inet_del_protocol</code></p>

<pre><code> 34 /*
 35  *      Add a protocol handler to the hash tables
 36  */
 37 
 38 int inet_add_protocol(const struct net_protocol *prot, unsigned char protocol)
 39 {
 40         if (!prot-&gt;netns_ok) {
 41                 pr_err("Protocol %u is not namespace aware, cannot register.\n",
 42                         protocol);
 43                 return -EINVAL;
 44         }
 45 
 46         return !cmpxchg((const struct net_protocol **)&amp;inet_protos[protocol],
 47                         NULL, prot) ? 0 : -1;
 48 }
 49 EXPORT_SYMBOL(inet_add_protocol);
</code></pre>

<pre><code> 58 /*
 59  *      Remove a protocol from the hash tables.
 60  */
 61 
 62 int inet_del_protocol(const struct net_protocol *prot, unsigned char protocol)
 63 {
 64         int ret;
 65 
 66         ret = (cmpxchg((const struct net_protocol **)&amp;inet_protos[protocol],
 67                        prot, NULL) == prot) ? 0 : -1;
 68 
 69         synchronize_net();
 70 
 71         return ret;
 72 }
 73 EXPORT_SYMBOL(inet_del_protocol);
 74 
</code></pre>

<p>All registered protocol handler.
<code>
$ grep inet_add_protocol net/ -Rw
net/dccp/ipv4.c:    err = inet_add_protocol(&amp;dccp_v4_protocol, IPPROTO_DCCP);
net/sctp/protocol.c:    if (inet_add_protocol(&amp;sctp_protocol, IPPROTO_SCTP) &lt; 0)
net/l2tp/l2tp_ip.c: err = inet_add_protocol(&amp;l2tp_ip_protocol, IPPROTO_L2TP);
net/ipv4/ipmr.c:    if (inet_add_protocol(&amp;pim_protocol, IPPROTO_PIM) &lt; 0) {
net/ipv4/esp4.c:    if (inet_add_protocol(&amp;esp4_protocol, IPPROTO_ESP) &lt; 0) {
net/ipv4/protocol.c:int inet_add_protocol(const struct net_protocol *prot, unsigned char protocol)
net/ipv4/protocol.c:EXPORT_SYMBOL(inet_add_protocol);
net/ipv4/af_inet.c: if (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; 0)
net/ipv4/af_inet.c: if (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0)
net/ipv4/af_inet.c: if (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0)
net/ipv4/af_inet.c: if (inet_add_protocol(&amp;igmp_protocol, IPPROTO_IGMP) &lt; 0)
net/ipv4/ah4.c: if (inet_add_protocol(&amp;ah4_protocol, IPPROTO_AH) &lt; 0) {
net/ipv4/tunnel4.c: if (inet_add_protocol(&amp;tunnel4_protocol, IPPROTO_IPIP)) {
net/ipv4/tunnel4.c: if (inet_add_protocol(&amp;tunnel64_protocol, IPPROTO_IPV6)) {
net/ipv4/ipcomp.c:  if (inet_add_protocol(&amp;ipcomp4_protocol, IPPROTO_COMP) &lt; 0) {
net/ipv4/udplite.c: if (inet_add_protocol(&amp;udplite_protocol, IPPROTO_UDPLITE) &lt; 0)
net/ipv4/gre_demux.c:   if (inet_add_protocol(&amp;net_gre_protocol, IPPROTO_GRE) &lt; 0) {
</code></p>

<h4>regiter protocol handler for tcp, udp and icmp.</h4>

<pre><code>1670 static int __init inet_init(void)
1671 {
...
1710         /*
1711          *      Add all the base protocols.
1712          */
1713 
1714         if (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; 0)
1715                 pr_crit("%s: Cannot add ICMP protocol\n", __func__);
1716         if (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0)
1717                 pr_crit("%s: Cannot add UDP protocol\n", __func__);
1718         if (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0)
1719                 pr_crit("%s: Cannot add TCP protocol\n", __func__);
...
</code></pre>

<h4>call protocol handler in the end of IPv4 process.</h4>

<p>NOTE:
1. <code>no_policy</code>: if it is set, <code>xfrm4_policy_check</code> will be
postponed and done by handler itself. such as <code>tcp</code>, <code>udp</code>.</p>

<pre><code>190 static int ip_local_deliver_finish(struct sk_buff *skb)
191 {
192         struct net *net = dev_net(skb-&gt;dev);
193 
194         __skb_pull(skb, skb_network_header_len(skb));
195 
196         rcu_read_lock();
197         {
198                 int protocol = ip_hdr(skb)-&gt;protocol;
199                 const struct net_protocol *ipprot;
200                 int raw;
201 
202         resubmit:
203                 raw = raw_local_deliver(skb, protocol);
204 
205                 ipprot = rcu_dereference(inet_protos[protocol]);
206                 if (ipprot != NULL) {
207                         int ret;
208 
209                         if (!ipprot-&gt;no_policy) {
210                                 if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
211                                         kfree_skb(skb);
212                                         goto out;
213                                 }
214                                 nf_reset(skb);
215                         }
216                         ret = ipprot-&gt;handler(skb);
217                         if (ret &lt; 0) {
218                                 protocol = -ret;
219                                 goto resubmit;
220                         }
221                         IP_INC_STATS_BH(net, IPSTATS_MIB_INDELIVERS);
222                 } else {
223                         if (!raw) {
224                                 if (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {
225                                         IP_INC_STATS_BH(net, IPSTATS_MIB_INUNKNOWNPROTOS);
226                                         icmp_send(skb, ICMP_DEST_UNREACH,
227                                                   ICMP_PROT_UNREACH, 0);
228                                 }
229                                 kfree_skb(skb);
230                         } else {
231                                 IP_INC_STATS_BH(net, IPSTATS_MIB_INDELIVERS);
232                                 consume_skb(skb);
233                         }
234                 }
235         }
236  out:
237         rcu_read_unlock();
238 
239         return 0;
240 }
</code></pre>

<h3>IPV6 part</h3>

<h4><code>struct inet6_protocol</code></h4>

<pre><code> 49 #if IS_ENABLED(CONFIG_IPV6)
 50 struct inet6_protocol {
 51         void    (*early_demux)(struct sk_buff *skb);
 52 
 53         int     (*handler)(struct sk_buff *skb);
 54 
 55         void    (*err_handler)(struct sk_buff *skb,
 56                                struct inet6_skb_parm *opt,
 57                                u8 type, u8 code, int offset,
 58                                __be32 info);
 59         unsigned int    flags;  /* INET6_PROTO_xxx */
 60 };
 61 
 62 #define INET6_PROTO_NOPOLICY    0x1
 63 #define INET6_PROTO_FINAL       0x2
 64 #endif
</code></pre>

<h4>ADD and DEL</h4>

<pre><code> 29 const struct inet6_protocol __rcu *inet6_protos[MAX_INET_PROTOS] __read_mostly;
 30 EXPORT_SYMBOL(inet6_protos);
 31 
 32 int inet6_add_protocol(const struct inet6_protocol *prot, unsigned char protocol)
 33 {
 34         return !cmpxchg((const struct inet6_protocol **)&amp;inet6_protos[protocol],
 35                         NULL, prot) ? 0 : -1;
 36 }
 37 EXPORT_SYMBOL(inet6_add_protocol);
 38 
 39 /*
 40  *      Remove a protocol from the hash tables.
 41  */
 42 
 43 int inet6_del_protocol(const struct inet6_protocol *prot, unsigned char protocol)
 44 {
 45         int ret;
 46 
 47         ret = (cmpxchg((const struct inet6_protocol **)&amp;inet6_protos[protocol],
 48                        prot, NULL) == prot) ? 0 : -1;
 49 
 50         synchronize_net();
 51 
 52         return ret;
 53 }
 54 EXPORT_SYMBOL(inet6_del_protocol);
</code></pre>

<h4>protocol handlers</h4>

<pre><code>$ grep inet6_add_protocol net/ -Rw
net/dccp/ipv6.c:    err = inet6_add_protocol(&amp;dccp_v6_protocol, IPPROTO_DCCP);
net/sctp/ipv6.c:    if (inet6_add_protocol(&amp;sctpv6_protocol, IPPROTO_SCTP) &lt; 0)
net/ipv6/exthdrs.c: ret = inet6_add_protocol(&amp;rthdr_protocol, IPPROTO_ROUTING);
net/ipv6/exthdrs.c: ret = inet6_add_protocol(&amp;destopt_protocol, IPPROTO_DSTOPTS);
net/ipv6/exthdrs.c: ret = inet6_add_protocol(&amp;nodata_protocol, IPPROTO_NONE);
net/ipv6/icmp.c:    if (inet6_add_protocol(&amp;icmpv6_protocol, IPPROTO_ICMPV6) &lt; 0)
net/ipv6/ip6mr.c:   if (inet6_add_protocol(&amp;pim6_protocol, IPPROTO_PIM) &lt; 0) {
net/ipv6/esp6.c:    if (inet6_add_protocol(&amp;esp6_protocol, IPPROTO_ESP) &lt; 0) {
net/ipv6/protocol.c:int inet6_add_protocol(const struct inet6_protocol *prot, unsigned char protocol)
net/ipv6/protocol.c:EXPORT_SYMBOL(inet6_add_protocol);
net/ipv6/ip6_gre.c: err = inet6_add_protocol(&amp;ip6gre_protocol, IPPROTO_GRE);
net/ipv6/reassembly.c:  ret = inet6_add_protocol(&amp;frag_protocol, IPPROTO_FRAGMENT);
net/ipv6/ipcomp6.c: if (inet6_add_protocol(&amp;ipcomp6_protocol, IPPROTO_COMP) &lt; 0) {
net/ipv6/udp.c: ret = inet6_add_protocol(&amp;udpv6_protocol, IPPROTO_UDP);
net/ipv6/ah6.c: if (inet6_add_protocol(&amp;ah6_protocol, IPPROTO_AH) &lt; 0) {
net/ipv6/tcp_ipv6.c:    ret = inet6_add_protocol(&amp;tcpv6_protocol, IPPROTO_TCP);
net/ipv6/udplite.c: ret = inet6_add_protocol(&amp;udplitev6_protocol, IPPROTO_UDPLITE);
net/ipv6/tunnel6.c: if (inet6_add_protocol(&amp;tunnel6_protocol, IPPROTO_IPV6)) {
net/ipv6/tunnel6.c: if (inet6_add_protocol(&amp;tunnel46_protocol, IPPROTO_IPIP)) {
net/l2tp/l2tp_ip6.c:    err = inet6_add_protocol(&amp;l2tp_ip6_protocol, IPPROTO_L2TP);
</code></pre>

<pre><code>1951 static const struct inet6_protocol tcpv6_protocol = {
1952         .early_demux    =       tcp_v6_early_demux,
1953         .handler        =       tcp_v6_rcv,
1954         .err_handler    =       tcp_v6_err,
1955         .flags          =       INET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,
1956 };
</code></pre>

<h4>call protocol handler in the end of ipv6 process.</h4>

<pre><code>200 
201 static int ip6_input_finish(struct sk_buff *skb)
202 {
...
222         raw = raw6_local_deliver(skb, nexthdr);
223         if ((ipprot = rcu_dereference(inet6_protos[nexthdr])) != NULL) {
224                 int ret;
225 
226                 if (ipprot-&gt;flags &amp; INET6_PROTO_FINAL) {
227                         const struct ipv6hdr *hdr;
228 
229                         /* Free reference early: we don't need it any more,
230                            and it may hold ip_conntrack module loaded
231                            indefinitely. */
232                         nf_reset(skb);
233 
234                         skb_postpull_rcsum(skb, skb_network_header(skb),
235                                            skb_network_header_len(skb));
236                         hdr = ipv6_hdr(skb);
237                         if (ipv6_addr_is_multicast(&amp;hdr-&gt;daddr) &amp;&amp;
238                             !ipv6_chk_mcast_addr(skb-&gt;dev, &amp;hdr-&gt;daddr,
239                             &amp;hdr-&gt;saddr) &amp;&amp;
240                             !ipv6_is_mld(skb, nexthdr, skb_network_header_len(skb)))
241                                 goto discard;
242                 }
243                 if (!(ipprot-&gt;flags &amp; INET6_PROTO_NOPOLICY) &amp;&amp;
244                     !xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
245                         goto discard;
246 
247                 ret = ipprot-&gt;handler(skb);
248                 if (ret &gt; 0)
249                         goto resubmit;
250                 else if (ret == 0)
251                         IP6_INC_STATS_BH(net, idev, IPSTATS_MIB_INDELIVERS);
252         } else {
...
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Inheriting of Linux Sock Type]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/11/22/the-inheriting-of-linux-sock-type/"/>
    <updated>2013-11-22T17:50:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/11/22/the-inheriting-of-linux-sock-type</id>
    <content type="html"><![CDATA[<h3>Data Structure</h3>

<p>Every <code>xsock</code> has parent sock as its first filed.</p>

<!-- more -->


<ol>
<li><code>sock_common</code>
<code>c
157 struct sock_common {
...
}
</code></li>
<li><code>sock</code>
<code>c
288 struct sock {
289         /*
290          * Now struct inet_timewait_sock also uses sock_common, so please just
291          * don't add nothing before this first member (__sk_common) --acme
292          */
293         struct sock_common      __sk_common;
...
</code></li>
<li><code>inet_sock</code>
<code>c
37 struct inet_sock {
138         /* sk and pinet6 has to be the first two members of inet_sock */
139         struct sock             sk;
...
</code></li>
<li><code>inet_connection_sock</code>
<code>c
87 struct inet_connection_sock {
88         /* inet_sock has to be the first member! */
89         struct inet_sock          icsk_inet;
...
</code></li>
<li><code>tcp_sock</code>
<code>c
133 struct tcp_sock {
134         /* inet_connection_sock has to be the first member of tcp_sock */
135         struct inet_connection_sock     inet_conn;
...
</code></li>
</ol>


<p><img src="/images/sock/tcpsock.jpg" alt="Inherit" /></p>
]]></content>
  </entry>
  
</feed>
