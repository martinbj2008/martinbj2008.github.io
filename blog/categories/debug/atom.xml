<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Debug | My Octopress Blog]]></title>
  <link href="http://martinbj2008.github.io/blog/categories/debug/atom.xml" rel="self"/>
  <link href="http://martinbj2008.github.io/"/>
  <updated>2015-05-21T16:26:25+08:00</updated>
  <id>http://martinbj2008.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ftrace Study]]></title>
    <link href="http://martinbj2008.github.io/blog/2014/10/21/ftrace-study/"/>
    <updated>2014-10-21T14:45:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2014/10/21/ftrace-study</id>
    <content type="html"><![CDATA[<h3>test case</h3>

<p>We found ixgbe  rx softirq  poll function <code>ixgbe_poll</code> was called even without pkt coming.
how to prove it and who call it?</p>

<h3>analysis</h3>

<p>By browse source <code>ixgbe_poll</code> is called, it should be done by napi schedule.
If this is true, <code>__napi_schedule</code> should be called.</p>

<!-- more -->


<h3>use ftrace to locate:</h3>

<h5>prepare debugfs</h5>

<pre><code class="c">mount -t debugfs none /sys/kernel/debug/
cd  /sys/kernel/debug/tracing
</code></pre>

<h4>step1: who call <code>__napi_schedule</code></h4>

<pre><code class="c">echo function &gt; current_tracer
echo 1 &gt; options/func_stack_trace
echo __napi_schedule &gt; set_ftrace_filter
cat set_ftrace_filter
cat trace  &gt; ~/a
</code></pre>

<h4>step2: who call <code>ixgbe_msix_clean_rings</code></h4>

<pre><code>echo function &gt; current_tracer
echo 1 &gt; options/func_stack_trace
echo ixgbe_msix_clean_rings &gt; set_ftrace_filter
cat set_ftrace_filter
cat trace  &gt; ~/a
</code></pre>

<h4>ftrace document</h4>

<p>Debugging the kernel using Ftrace
part 1
<a href="http://lwn.net/Articles/365835/">http://lwn.net/Articles/365835/</a></p>

<p>part 2
<a href="http://lwn.net/Articles/366796/">http://lwn.net/Articles/366796/</a></p>

<p>Secrets of the Ftrace function tracer
<a href="http://lwn.net/Articles/370423/">http://lwn.net/Articles/370423/</a></p>

<p>Debugging Linux Kernel by Ftrace by AceLan Kao
<a href="http://people.canonical.com/~acelan/coscup-2010/Debugging%20Linux%20Kernel%20by%20Ftrace.pdf">http://people.canonical.com/~acelan/coscup-2010/Debugging%20Linux%20Kernel%20by%20Ftrace.pdf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug Kernel With Jprobe]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/08/23/debug-kernel-with-jprobe/"/>
    <updated>2013-08-23T11:13:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/08/23/debug-kernel-with-jprobe</id>
    <content type="html"><![CDATA[<h2>kprobe is a useful tool when debug kernel.</h2>

<p>It can directly hook the related function of kernel,
before or after it run.</p>

<p>It also can be used to patch kernel in some special case.</p>

<!-- more -->


<h2>example</h2>

<p>We can update kernel stat before kernel show it.</p>

<pre><code class="c">  1 #include &lt;linux/version.h&gt;
  2 #include &lt;linux/module.h&gt;
  3 #include &lt;linux/kallsyms.h&gt;
  4 #include &lt;linux/kprobes.h&gt;
  5 
  6 static int martin_snmp_seq_show(struct seq_file *seq, void *v)
  7 {
  8         printk(KERN_INFO "%s: called\n", __func__);
  9 
 10         jprobe_return();
 11         return 0;
 12 }
 13 
 14 static int martin_snmp6_seq_show(struct seq_file *seq, void *v)
 15 {  
 16         printk(KERN_INFO "%s: called\n", __func__);
 17    
 18         jprobe_return();
 19         return 0;
 20 }
 21 
 22 static struct jprobe martin_snmp_jprobe = {
 23         .entry = martin_snmp_seq_show,
 24         .kp = {
 25                 .symbol_name = "snmp_seq_show",          
 26         },
 27 };
 28 
 29 static struct jprobe martin_snmp6_jprobe = {
 30         .entry = martin_snmp6_seq_show,
 31         .kp = {
 32                 .symbol_name = "snmp6_seq_show",         
 33         },
 34 };
 35 
 36 static struct jprobe* martin_jprobes[] = {
 37         &amp;martin_snmp_jprobe,
 38         &amp;martin_snmp6_jprobe,
 39 };
 40 
 41 int __init martin_jprobe_init(void)
 42 {
 43         const int cnt = sizeof(martin_jprobes)/sizeof(struct jprobe *);
 44 
 45         if (register_jprobes(martin_jprobes, cnt) &lt; 0) {
 46                 printk(KERN_INFO "FPS: register_jprobe failed !!!\n");
 47                 return -1;
 48         }
 49 
 50         printk(KERN_INFO "FPS: ready\n");        
 51         return 0;
 52 }
 53 
 54 void __exit martin_jprobe_exit(void)
 55 {
 56         const int cnt = sizeof(martin_jprobes)/sizeof(struct jprobe *);
 57 
 58         unregister_jprobes(martin_jprobes, cnt);
 59 
 60         printk(KERN_INFO "FPS: coloc martin module exit.\n");
 61 }
 62 
 63 module_init(martin_jprobe_init);
 64 module_exit(martin_jprobe_exit);
 65 
 66 MODULE_DESCRIPTION("MartinJPROBE");
 67 MODULE_LICENSE("GPL");
</code></pre>
]]></content>
  </entry>
  
</feed>
