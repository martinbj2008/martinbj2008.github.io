<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xfrm | My Octopress Blog]]></title>
  <link href="http://martinbj2008.github.io/blog/categories/xfrm/atom.xml" rel="self"/>
  <link href="http://martinbj2008.github.io/"/>
  <updated>2015-05-21T16:26:25+08:00</updated>
  <id>http://martinbj2008.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Does Xfrm Km Work]]></title>
    <link href="http://martinbj2008.github.io/blog/2013/08/26/how-does-xfrm-km-work/"/>
    <updated>2013-08-26T15:19:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2013/08/26/how-does-xfrm-km-work</id>
    <content type="html"><![CDATA[<h3>summary</h3>

<p>There is a list <code>xfrm_km_list</code> in kernel.
Each node of the list is <code>struct xfrm_mgr</code>,
which has several methods to notify usersapce by netlink message.
Different methods has corresponding method,
and it broadcast the netlink message with different xfrm groups.</p>

<p><code>struct xfrm_mgr</code> has many methods, for example:
    1. notify:  notify the sa change, ex: add, delete, expire ..
    2. acquire: notify when sp is match, while no SA is got.
    3. compile_policy:
    4. new_mapping:
    5: notify_policy: notify sp change. add, delete, expire.
    6. report:
    7. mirgrate:</p>

<!-- more -->


<h4><code>struct xfrm_mgr</code> and <code>xfrm_km_list</code></h4>

<pre><code class="c">1630 static LIST_HEAD(xfrm_km_list);
</code></pre>

<pre><code class="c"> 579 struct xfrm_mgr {
 580         struct list_head        list;
 581         char                    *id;
 582         int                     (*notify)(struct xfrm_state *x, const struct km_event *c);
 583         int                     (*acquire)(struct xfrm_state *x, struct xfrm_tmpl *, struct xfrm_policy *xp);
 584         struct xfrm_policy      *(*compile_policy)(struct sock *sk, int opt, u8 *data, int len, int *dir);
 585         int                     (*new_mapping)(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);
 586         int                     (*notify_policy)(struct xfrm_policy *x, int dir, const struct km_event *c);
 587         int                     (*report)(struct net *net, u8 proto, struct xfrm_selector *sel, xfrm_address_t *addr);
 588         int                     (*migrate)(const struct xfrm_selector *sel,
 589                                            u8 dir, u8 type,
 590                                            const struct xfrm_migrate *m,
 591                                            int num_bundles,
 592                                            const struct xfrm_kmaddress *k);
 593 };
</code></pre>

<h4><code>xfrm_register_km</code> vs <code>xfrm_unregister_km</code></h4>

<p>Register or unregister a <code>xfrm_mgr</code> to <code>xfrm_km_list</code>.</p>

<p>NOTE:  here we <code>use spin_lock_bh</code>,
because the <code>km_notify</code> method maybe used in irq bottom half.
ex: the first packet which trigger the dynamic sa
negotiation, which is processed in softirq(rx).</p>

<pre><code class="c">1807 int xfrm_register_km(struct xfrm_mgr *km)
1808 {
1809         spin_lock_bh(&amp;xfrm_km_lock);
1810         list_add_tail_rcu(&amp;km-&gt;list, &amp;xfrm_km_list);
1811         spin_unlock_bh(&amp;xfrm_km_lock);
1812         return 0;
1813 }
</code></pre>

<pre><code class="c">1816 int xfrm_unregister_km(struct xfrm_mgr *km)
1817 {
1818         spin_lock_bh(&amp;xfrm_km_lock);
1819         list_del_rcu(&amp;km-&gt;list);
1820         spin_unlock_bh(&amp;xfrm_km_lock);
1821         synchronize_rcu();
1822         return 0;
1823 }
</code></pre>

<h4>register with <code>netlink_mgr</code></h4>

<pre><code class="c">3031 static int __init xfrm_user_init(void)
...
3040         rv = xfrm_register_km(&amp;netlink_mgr);
...
</code></pre>

<pre><code class="c">2989 static struct xfrm_mgr netlink_mgr = {
2990         .id             = "netlink",
2991         .notify         = xfrm_send_state_notify,
2992         .acquire        = xfrm_send_acquire,
2993         .compile_policy = xfrm_compile_policy,
2994         .notify_policy  = xfrm_send_policy_notify,
2995         .report         = xfrm_send_report,
2996         .migrate        = xfrm_send_migrate,
2997         .new_mapping    = xfrm_send_mapping,
2998 };
</code></pre>

<h4><code>km_state_expired</code></h4>

<pre><code class="c">1643 void km_state_notify(struct xfrm_state *x, const struct km_event *c)
1644 {
1645         struct xfrm_mgr *km;
1646         rcu_read_lock();
1647         list_for_each_entry_rcu(km, &amp;xfrm_km_list, list)
1648                 if (km-&gt;notify)
1649                         km-&gt;notify(x, c);
1650         rcu_read_unlock();
1651 }
</code></pre>

<pre><code class="c">1656 void km_state_expired(struct xfrm_state *x, int hard, u32 portid)
1657 {
1658         struct net *net = xs_net(x);
1659         struct km_event c;
1660
1661         c.data.hard = hard;
1662         c.portid = portid;
1663         c.event = XFRM_MSG_EXPIRE;
1664         km_state_notify(x, &amp;c);
1665
1666         if (hard)
1667                 wake_up(&amp;net-&gt;xfrm.km_waitq);
1668 }
1669
1670 EXPORT_SYMBOL(km_state_expired);
</code></pre>

<h4><code>km_policy_expired</code> vs <code>km_policy_notify</code></h4>

<pre><code class="c">1632 void km_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
1633 {
1634         struct xfrm_mgr *km;
1635
1636         rcu_read_lock();
1637         list_for_each_entry_rcu(km, &amp;xfrm_km_list, list)
1638                 if (km-&gt;notify_policy)
1639                         km-&gt;notify_policy(xp, dir, c);
1640         rcu_read_unlock();
1641 }
</code></pre>

<pre><code class="c">1708 void km_policy_expired(struct xfrm_policy *pol, int dir, int hard, u32 portid)
1709 {
1710         struct net *net = xp_net(pol);
1711         struct km_event c;
1712
1713         c.data.hard = hard;
1714         c.portid = portid;
1715         c.event = XFRM_MSG_POLEXPIRE;
1716         km_policy_notify(pol, dir, &amp;c);
1717
1718         if (hard)
1719                 wake_up(&amp;net-&gt;xfrm.km_waitq);
1720 }
1721 EXPORT_SYMBOL(km_policy_expired);
</code></pre>

<h4><code>xfrm_send_state_notify</code></h4>

<pre><code class="c">2577 static int xfrm_send_state_notify(struct xfrm_state *x, const struct km_event *c)
2578 {
2579
2580         switch (c-&gt;event) {
2581         case XFRM_MSG_EXPIRE:
2582                 return xfrm_exp_state_notify(x, c);
2583         case XFRM_MSG_NEWAE:
2584                 return xfrm_aevent_state_notify(x, c);
2585         case XFRM_MSG_DELSA:
2586         case XFRM_MSG_UPDSA:
2587         case XFRM_MSG_NEWSA:
2588                 return xfrm_notify_sa(x, c);
2589         case XFRM_MSG_FLUSHSA:
2590                 return xfrm_notify_sa_flush(c);
2591         default:
2592                 printk(KERN_NOTICE "xfrm_user: Unknown SA event %d\n",
2593                        c-&gt;event);
2594                 break;
2595         }
2596
2597         return 0;
2598
2599 }
</code></pre>

<pre><code class="c">2428 static int xfrm_exp_state_notify(struct xfrm_state *x, const struct km_event *c)
2429 {
2430         struct net *net = xs_net(x);
2431         struct sk_buff *skb;
2432
2433         skb = nlmsg_new(xfrm_expire_msgsize(), GFP_ATOMIC);
2434         if (skb == NULL)
2435                 return -ENOMEM;
2436
2437         if (build_expire(skb, x, c) &lt; 0) {
2438                 kfree_skb(skb);
2439                 return -EMSGSIZE;
2440         }
2441
2442         return nlmsg_multicast(net-&gt;xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);
2443 }
</code></pre>

<h4><code>xfrm_send_acquire</code></h4>

<pre><code class="c">2648 static int xfrm_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *xt,
2649                              struct xfrm_policy *xp)
2650 {
2651         struct net *net = xs_net(x);
2652         struct sk_buff *skb;
2653
2654         skb = nlmsg_new(xfrm_acquire_msgsize(x, xp), GFP_ATOMIC);
2655         if (skb == NULL)
2656                 return -ENOMEM;
2657
2658         if (build_acquire(skb, x, xt, xp) &lt; 0)
2659                 BUG();
2660
2661         return nlmsg_multicast(net-&gt;xfrm.nlsk, skb, 0, XFRMNLGRP_ACQUIRE, GFP_ATOMIC);
2662 }
</code></pre>

<h4>how to notify strongswan negotiate a new sa.</h4>

<pre><code class="c">&gt; xfrm_stat_find
&gt; &gt;  km_query
&gt; &gt; &gt;  km-&gt;acquire
equal:
&gt; &gt; &gt;  xfrm_send_acquire
</code></pre>

<pre><code class="c">1671 /*
1672  * We send to all registered managers regardless of failure
1673  * We are happy with one success
1674 */
1675 int km_query(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *pol)
1676 {
1677         int err = -EINVAL, acqret;
1678         struct xfrm_mgr *km;
1679
1680         rcu_read_lock();
1681         list_for_each_entry_rcu(km, &amp;xfrm_km_list, list) {
1682                 acqret = km-&gt;acquire(x, t, pol);
1683                 if (!acqret)
1684                         err = acqret;
1685         }
1686         rcu_read_unlock();
1687         return err;
1688 }
1689 EXPORT_SYMBOL(km_query);
</code></pre>

<pre><code class="c"> 788 struct xfrm_state *
 789 xfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,
 790                 const struct flowi *fl, struct xfrm_tmpl *tmpl,
 791                 struct xfrm_policy *pol, int *err,
 792                 unsigned short family)
 793 {
...
 838         x = best;
 839         if (!x &amp;&amp; !error &amp;&amp; !acquire_in_progress) {
 840                 if (tmpl-&gt;id.spi &amp;&amp;
 841                     (x0 = __xfrm_state_lookup(net, mark, daddr, tmpl-&gt;id.spi,
 842                                               tmpl-&gt;id.proto, encap_family)) != NULL) {
 843                         to_put = x0;
 844                         error = -EEXIST;
 845                         goto out;
 846                 }
 847                 x = xfrm_state_alloc(net);
 848                 if (x == NULL) {
 849                         error = -ENOMEM;
 850                         goto out;
 851                 }
 852                 /* Initialize temporary state matching only
 853                  * to current session. */
 854                 xfrm_init_tempstate(x, fl, tmpl, daddr, saddr, family);
 855                 memcpy(&amp;x-&gt;mark, &amp;pol-&gt;mark, sizeof(x-&gt;mark));
 856
 857                 error = security_xfrm_state_alloc_acquire(x, pol-&gt;security, fl-&gt;flowi_secid);
 858                 if (error) {
 859                         x-&gt;km.state = XFRM_STATE_DEAD;
 860                         to_put = x;
 861                         x = NULL;
 862                         goto out;
 863                 }
 864
 865                 if (km_query(x, tmpl, pol) == 0) {
 866                         x-&gt;km.state = XFRM_STATE_ACQ;
 867                         list_add(&amp;x-&gt;km.all, &amp;net-&gt;xfrm.state_all);
 868                         hlist_add_head(&amp;x-&gt;bydst, net-&gt;xfrm.state_bydst+h);
</code></pre>

<h4>pernet <code>net-&gt;xfrm.nlsk</code></h4>

<p>It is a basic of xfrm netlink.
All the message sent to/from kernel will use it.
See detail with blog about netlink.</p>

<p><a href="http://martinbj2008.github.io/blog/2013/02/16/netlink-in-kernel">http://martinbj2008.github.io/blog/2013/02/16/netlink-in-kernel</a>
<a href="http://martinbj2008.github.io/blog/2013/03/15/netlink-in-kernel">http://martinbj2008.github.io/blog/2013/03/15/netlink-in-kernel</a></p>

<pre><code class="c">3000 static int __net_init xfrm_user_net_init(struct net *net)
3001 {
3002         struct sock *nlsk;
3003         struct netlink_kernel_cfg cfg = {
3004                 .groups = XFRMNLGRP_MAX,
3005                 .input  = xfrm_netlink_rcv,
3006         };
3007
3008         nlsk = netlink_kernel_create(net, NETLINK_XFRM, &amp;cfg);
3009         if (nlsk == NULL)
3010                 return -ENOMEM;
3011         net-&gt;xfrm.nlsk_stash = nlsk; /* Don't set to NULL */
3012         rcu_assign_pointer(net-&gt;xfrm.nlsk, nlsk);
3013         return 0;
3014 }
</code></pre>

<h4><code>net-&gt;xfrm.km_waitq</code></h4>

<p>It is used to wait SA negotiation complete,
and is not related with km.</p>

<pre><code class="c">2121         if (route == NULL &amp;&amp; num_xfrms &gt; 0) {
2122                 /* The only case when xfrm_bundle_lookup() returns a
2123                  * bundle with null route, is when the template could
2124                  * not be resolved. It means policies are there, but
2125                  * bundle could not be created, since we don't yet
2126                  * have the xfrm_state's. We need to wait for KM to
2127                  * negotiate new SA's or bail out with error.*/
2128                 if (net-&gt;xfrm.sysctl_larval_drop) {
2129                         /* EREMOTE tells the caller to generate
2130                          * a one-shot blackhole route. */
2131                         dst_release(dst);
2132                         xfrm_pols_put(pols, drop_pols);
2133                         XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);
2134
2135                         return make_blackhole(net, family, dst_orig);
2136                 }
2137                 if (fl-&gt;flowi_flags &amp; FLOWI_FLAG_CAN_SLEEP) {
2138                         DECLARE_WAITQUEUE(wait, current);
2139
2140                         add_wait_queue(&amp;net-&gt;xfrm.km_waitq, &amp;wait);
2141                         set_current_state(TASK_INTERRUPTIBLE);
2142                         schedule();
2143                         set_current_state(TASK_RUNNING);
2144                         remove_wait_queue(&amp;net-&gt;xfrm.km_waitq, &amp;wait);
2145
2146                         if (!signal_pending(current)) {
2147                                 dst_release(dst);
2148                                 goto restart;
2149                         }
2150
2151                         err = -ERESTART;
2152                 } else
2153                         err = -EAGAIN;
2154
2155                 XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);
2156                 goto error;
2157         }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Get or Delete Xfrm Policy]]></title>
    <link href="http://martinbj2008.github.io/blog/2012/11/10/get-delete-xfrm-policy/"/>
    <updated>2012-11-10T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2012/11/10/get-delete-xfrm-policy</id>
    <content type="html"><![CDATA[<h2>summary</h2>

<p>xfrm_get_policy first locate the xfrm policy by policy index(from user space) or policy selector.</p>

<ol>
<li>if get_policy, alloc a new skb, and encapsulate the xfrm policy to it, then sent  it.</li>
<li>if delete policy, call <code>xfrm_audit_policy_delete</code> to delete the plolicy, and call km_policy_notify to notify.</li>
</ol>


<p>xfrm policy del/get 使用的是同一个函数 <code>xfrm_get_policy</code>.</p>

<!-- more -->


<pre><code class="c ">2291         [XFRM_MSG_DELPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },
2292         [XFRM_MSG_GETPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,
</code></pre>

<h2>data struct</h2>

<pre><code>405 struct xfrm_userpolicy_id {
406         struct xfrm_selector            sel;
407         __u32                           index;
408         __u8                            dir;
409 };
</code></pre>

<h2>functions</h2>

<pre><code>1567 static int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,
1568                 struct nlattr **attrs)
1569 {
1570         struct net *net = sock_net(skb-&gt;sk);
1571         struct xfrm_policy *xp;
1572         struct xfrm_userpolicy_id *p;
1573         u8 type = XFRM_POLICY_TYPE_MAIN;
1574         int err;
1575         struct km_event c;
1576         int delete;
1577         struct xfrm_mark m;
1578         u32 mark = xfrm_mark_get(attrs, &amp;m);
1579
1580         p = nlmsg_data(nlh);
1581         delete = nlh-&gt;nlmsg_type == XFRM_MSG_DELPOLICY;
1582
1583         err = copy_from_user_policy_type(&amp;type, attrs);
1584         if (err)
1585                 return err;
1586
1587         err = verify_policy_dir(p-&gt;dir);
1588         if (err)
1589                 return err;
1590/*start find the policy by index or by selector.*/
1591         if (p-&gt;index)
1592                 xp = xfrm_policy_byid(net, mark, type, p-&gt;dir, p-&gt;index, delete, &amp;err);
1593         else {
1594                 struct nlattr *rt = attrs[XFRMA_SEC_CTX];
1595                 struct xfrm_sec_ctx *ctx;
1596
1597                 err = verify_sec_ctx_len(attrs);
1598                 if (err)
1599                         return err;
1600
1601                 ctx = NULL;
1602                 if (rt) {
1603                         struct xfrm_user_sec_ctx *uctx = nla_data(rt);
1604
1605                         err = security_xfrm_policy_alloc(&amp;ctx, uctx);
1606                         if (err)
1607                                 return err;
1608                 }
1609                 xp = xfrm_policy_bysel_ctx(net, mark, type, p-&gt;dir, &amp;p-&gt;sel,
1610                                            ctx, delete, &amp;err);
1611                 security_xfrm_policy_free(ctx);
1612         }
1613         if (xp == NULL)
1614                 return -ENOENT;
1615
1616         if (!delete) { &lt;== 'get': encaplate to skb and sent it by netlink
1617                 struct sk_buff *resp_skb;
1618
1619                 resp_skb = xfrm_policy_netlink(skb, xp, p-&gt;dir, nlh-&gt;nlmsg_seq);
1620                 if (IS_ERR(resp_skb)) {
1621                         err = PTR_ERR(resp_skb);
1622                 } else {
1623                         err = nlmsg_unicast(net-&gt;xfrm.nlsk, resp_skb,
1624                                             NETLINK_CB(skb).pid);
1625                 }
1626         } else { &lt;== delete xfrm policy and sent a notify netlink message.
1627                 uid_t loginuid = audit_get_loginuid(current);
1628                 u32 sessionid = audit_get_sessionid(current);
1629                 u32 sid;
1630
1631                 security_task_getsecid(current, &amp;sid);
1632                 xfrm_audit_policy_delete(xp, err ? 0 : 1, loginuid, sessionid,
1633                                          sid);
1634
1635                 if (err != 0)
1636                         goto out;
1637
1638                 c.data.byid = p-&gt;index;
1639                 c.event = nlh-&gt;nlmsg_type;
1640                 c.seq = nlh-&gt;nlmsg_seq;
1641                 c.pid = nlh-&gt;nlmsg_pid;
1642                 km_policy_notify(xp, p-&gt;dir, &amp;c);
1643         }
1644
1645 out:
1646         xfrm_pol_put(xp);
1647         return err;
1648 }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add or Udpate Xfrm Policy]]></title>
    <link href="http://martinbj2008.github.io/blog/2012/11/10/add-update-xfrm-polciy/"/>
    <updated>2012-11-10T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2012/11/10/add-update-xfrm-polciy</id>
    <content type="html"><![CDATA[<p>xfrm policy add/del/update 是通过netlink消息进行的。 其中xfrm_add_policy 用来添加 xfrm policy。</p>

<!-- more -->


<h2>netlink message type</h2>

<pre><code>163         XFRM_MSG_NEWPOLICY,
164 #define XFRM_MSG_NEWPOLICY XFRM_MSG_NEWPOLICY
165         XFRM_MSG_DELPOLICY,
166 #define XFRM_MSG_DELPOLICY XFRM_MSG_DELPOLICY
167         XFRM_MSG_GETPOLICY,
168 #define XFRM_MSG_GETPOLICY XFRM_MSG_GETPOLICY
</code></pre>

<pre><code>2290         [XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
2291         [XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },
2292         [XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,
...
2298         [XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
</code></pre>

<pre><code> 501 struct xfrm_policy {
 502 #ifdef CONFIG_NET_NS
 503         struct net              *xp_net;
 504 #endif
 505         struct hlist_node       bydst;
 506         struct hlist_node       byidx;
 507
 508         /* This lock only affects elements except for entry. */
 509         rwlock_t                lock;
 510         atomic_t                refcnt;
 511         struct timer_list       timer;
 512
 513         struct flow_cache_object flo;
 514         atomic_t                genid;
 515         u32                     priority;
 516         u32                     index;
 517         struct xfrm_mark        mark;
 518         struct xfrm_selector    selector;
 519         struct xfrm_lifetime_cfg lft;
 520         struct xfrm_lifetime_cur curlft;
 521         struct xfrm_policy_walk_entry walk;
 522         u8                      type;
 523         u8                      action;
 524         u8                      flags;
 525         u8                      xfrm_nr;
 526         u16                     family;
 527         struct xfrm_sec_ctx     *security;
 528         struct xfrm_tmpl        xfrm_vec[XFRM_MAX_DEPTH];
 529 };
</code></pre>

<h2>Add a policy:</h2>

<pre><code>&gt; xfrm_add_policy
&gt; &gt; verify_newpolicy_info
&gt; &gt; xfrm_policy_construct
&gt; &gt; xfrm_policy_insert
&gt; &gt; &gt; policy_hash_bysel
&gt; &gt; &gt; hlist_for_each_entry
&gt; &gt; &gt; match ? hlist_add_after or hlist_add_head
&gt; &gt; &gt; hlist_add_head
&gt; &gt; &gt; mod_timer
&gt; &gt; &gt; list_add(&amp;policy-&gt;walk.all, &amp;net-&gt;xfrm.policy_all);
&gt; &gt; &gt; delpol ? xfrm_policy_kill(delpol);
&gt; &gt; &gt; xfrm_bydst_should_resize? schedule_work(&amp;net-&gt;xfrm.policy_hash_work);
&gt; &gt; km_policy_notify
&gt; &gt; xfrm_pol_put
</code></pre>

<pre><code>1363 static int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,
1364                 struct nlattr **attrs)
1365 {
1366         struct net *net = sock_net(skb-&gt;sk);
1367         struct xfrm_userpolicy_info *p = nlmsg_data(nlh);
1368         struct xfrm_policy *xp;
1369         struct km_event c;
1370         int err;
1371         int excl;
1372         uid_t loginuid = audit_get_loginuid(current);
1373         u32 sessionid = audit_get_sessionid(current);
1374         u32 sid;
1375
1376         err = verify_newpolicy_info(p);
1377         if (err)
1378                 return err;
1379         err = verify_sec_ctx_len(attrs);
1380         if (err)
1381                 return err;
1382
1383         xp = xfrm_policy_construct(net, p, attrs, &amp;err); &lt;== construct a xfrm policy with infmation from user space.
1384         if (!xp)
1385                 return err;
1386
1387         /* shouldn't excl be based on nlh flags??
1388          * Aha! this is anti-netlink really i.e  more pfkey derived
1389          * in netlink excl is a flag and you wouldnt need
1390          * a type XFRM_MSG_UPDPOLICY - JHS */
1391         excl = nlh-&gt;nlmsg_type == XFRM_MSG_NEWPOLICY;
1392         err = xfrm_policy_insert(p-&gt;dir, xp, excl);  &lt;== insert/update a xfrm policy.
1393         security_task_getsecid(current, &amp;sid);
1394         xfrm_audit_policy_add(xp, err ? 0 : 1, loginuid, sessionid, sid);
1395
1396         if (err) {
1397                 security_xfrm_policy_free(xp-&gt;security);
1398                 kfree(xp);
1399                 return err;
1400         }
1401
1402         c.event = nlh-&gt;nlmsg_type;
1403         c.seq = nlh-&gt;nlmsg_seq;
1404         c.pid = nlh-&gt;nlmsg_pid;
1405         km_policy_notify(xp, p-&gt;dir, &amp;c);  &lt;==== send notify message to KM.
1406
1407         xfrm_pol_put(xp);
1408
1409         return 0;
1410 }
</code></pre>

<p>xfrm policy is a hash list array, every element is a hist list. In the list the policies are sorted with increased policy’s priority.
<code>
 548 int xfrm_policy_insert(int dir, struct xfrm_policy *policy, int excl)
 549 {
 550         struct net *net = xp_net(policy);
 551         struct xfrm_policy *pol;
 552         struct xfrm_policy *delpol;
 553         struct hlist_head *chain;
 554         struct hlist_node *entry, *newpos;
 555         u32 mark = policy-&gt;mark.v &amp; policy-&gt;mark.m;
 556
 557         write_lock_bh(&amp;xfrm_policy_lock);  &lt;== use rw lock to protect xfrm polciy database.
 558         chain = policy_hash_bysel(net, &amp;policy-&gt;selector, policy-&gt;family, dir);
 559         delpol = NULL;
 560         newpos = NULL;
 561         hlist_for_each_entry(pol, entry, chain, bydst) {
 562                 if (pol-&gt;type == policy-&gt;type &amp;&amp;
 563                     !selector_cmp(&amp;pol-&gt;selector, &amp;policy-&gt;selector) &amp;&amp;
 564                     (mark &amp; pol-&gt;mark.m) == pol-&gt;mark.v &amp;&amp;
 565                     xfrm_sec_ctx_match(pol-&gt;security, policy-&gt;security) &amp;&amp;
 566                     !WARN_ON(delpol)) {
 567                         if (excl) {
 568                                 write_unlock_bh(&amp;xfrm_policy_lock);
 569                                 return -EEXIST;
 570                         }
 571                         delpol = pol;
 572                         if (policy-&gt;priority &gt; pol-&gt;priority)   &lt;====??? todo
 573                                 continue;
 574                 } else if (policy-&gt;priority &gt;= pol-&gt;priority) {
 575                         newpos = &amp;pol-&gt;bydst;
 576                         continue;
 577                 }
 578                 if (delpol)
 579                         break;
 580         }
 581         if (newpos)
 582                 hlist_add_after(newpos, &amp;policy-&gt;bydst);
 583         else
 584                 hlist_add_head(&amp;policy-&gt;bydst, chain);
 585         xfrm_pol_hold(policy);
 586         net-&gt;xfrm.policy_count[dir]++;
 587         atomic_inc(&amp;flow_cache_genid); &lt;== it will be used by flow cache.
 588         if (delpol)
 589                 __xfrm_policy_unlink(delpol, dir);
 590         policy-&gt;index = delpol ? delpol-&gt;index : xfrm_gen_index(net, dir);
 591         hlist_add_head(&amp;policy-&gt;byidx, net-&gt;xfrm.policy_byidx+idx_hash(net, policy-&gt;index));
 592         policy-&gt;curlft.add_time = get_seconds();
 593         policy-&gt;curlft.use_time = 0;
 594         if (!mod_timer(&amp;policy-&gt;timer, jiffies + HZ))
 595                 xfrm_pol_hold(policy);
 596         list_add(&amp;policy-&gt;walk.all, &amp;net-&gt;xfrm.policy_all);
 597         write_unlock_bh(&amp;xfrm_policy_lock);
 598
 599         if (delpol)
 600                 xfrm_policy_kill(delpol);
 601         else if (xfrm_bydst_should_resize(net, dir, NULL))
 602                 schedule_work(&amp;net-&gt;xfrm.policy_hash_work);
 603
 604         return 0;
 605 }
 606 EXPORT_SYMBOL(xfrm_policy_insert);
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xfrm Dump Sa]]></title>
    <link href="http://martinbj2008.github.io/blog/2012/02/10/xfrm-dump-sa/"/>
    <updated>2012-02-10T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2012/02/10/xfrm-dump-sa</id>
    <content type="html"><![CDATA[<h2>应用层通过pfkey，dump sa的步骤：</h2>

<ol>
<li>创建pfkeyl类型的一个socket，</li>
<li>通过sendmsg发送一个dump sa 的请求</li>
<li>然后通过while循环调用recvmsg</li>
</ol>


<!-- more -->


<h2>kernel里对应的处理：</h2>

<p>内核遍历存放SA的list。将SA的信息转化到一个或多个skb, 将这些skb添加到相应pfkey socket的sk_receive_queue链表里。
每次添加Skb时候会检查是否超出socket允许接受的最大receive字节数。
如果SA的数量比较多,则无法一次将所有的SA信息转化到skb里。</p>

<p>当SA的个数比较少时，一次性输出所有的SA是可以的， 但是当SA的个数非常大时， 一次性输出（遍历） 所有的sa是低效的(消耗大量内存），而且还要受到输出缓冲区buff的限制。</p>

<p>因此xfrm walk 采用分段遍历的方式，每次只顺着<code>net-&gt;xfrm.state_all</code>链表往后推进一步， 这样一次一步逐渐分批次把真个list的SA全部遍历完毕。 而<code>struct xfrm_state_walk</code>这个结构体就是用来记录当前这次遍历的位置。</p>

<p>具体实现就是将<code>xfrm_state_walk</code>这个结构体插入到<code>net-&gt;xfrm.state_all</code>这个hlisst上， 并位于最近一次遍历到的SA的后边。</p>

<p>在下一次继续遍历的时候,则从xfrm_state_walk这个结构体继续往后走， 如果遍历完全部SA，则把<code>xfrm_state_walk</code>这个结构体从<code>net-&gt;xfrm.state_all</code>上删除， 否则移动<code>xfrm_state_walk</code>这个结构体到本次遍历的最有一个SA的后面，并等待下次继续遍历。 如此反复，可以遍历完所有的SA, 最后删除xfrmwalk。</p>

<p>这是netlink callback机制在内核里的一个具体的实现。还有很多netlink callback的例子。
xfrm state采用的是个单链表。有个callback机制使用的是hlist.</p>

<p>无论hlist还是list，在dump时，是加锁的， 可以保证数据的一致性。
但是当数据量大的时候，callback机制无法保证，两次dump的过程中会有增删的操作。
因此应用层程序，可以有两种方式去解决这个问题：</p>

<ol>
<li>在dump的同时监听相应的增删消息。</li>
<li>判断netlink消息里是否有标志。如果有则重新dump。</li>
</ol>


<h3>calltrace</h3>

<pre><code class="c">== err = pfkey_process(sk, skb, hdr);
== == err = pfkey_funcs[hdr-&gt;sadb_msg_type](sk, skb, hdr, ext_hdrs);
== == == pfkey_dump
== == == == pfkey_do_dump
== == == == == pfk-&gt;dump.msg_pid = hdr-&gt;sadb_msg_pid;
== == == == == pfk-&gt;dump.dump = pfkey_dump_sa;
== == == == == pfk-&gt;dump.done = pfkey_dump_sa_done;
== == == == == xfrm_state_walk_init(&amp;pfk-&gt;dump.u.state, proto);
== == == return pfkey_do_dump(pfk);

##Data structure

1. 每个net都有一个netns_xfrm结构体，里面保存了xfrm的信息。
</code></pre>

<p>35 struct net {
&hellip;
87 #ifdef CONFIG_XFRM
88         struct netns_xfrm       xfrm;
89 #endif
```</p>

<ol>
<li>netns_xfrm下有一个state_all的list（双向循环）挂这改net下的所有的xfrm state。</li>
</ol>


<pre><code class="c">17 struct netns_xfrm {
18         struct list_head        state_all;
</code></pre>

<ol>
<li>每个xfrm state有一个 xfrm_state_walk类型的km， xfrm_state_walk里有个链all 最终每个xfrm state通过 km.all 挂在 net->xfrm.state_all这条链上。</li>
</ol>


<pre><code> 129 struct xfrm_state {
....
 149         /* Key manager bits */
 150         struct xfrm_state_walk  km; 
</code></pre>

<pre><code class="c"> 118 struct xfrm_state_walk {
 119         struct list_head        all;
 120         u8                      state;
 121         union {
 122                 u8              dying;
 123                 u8              proto;
 124         };
 125         u32                     seq;
 126 };      
</code></pre>

<p>因此遍历net->xfrm.state_all可以得到改net下的全部SA。</p>

<h2>functions</h2>

<ol>
<li><code>pfkey_do_dump</code></li>
</ol>


<pre><code class="c"> 279 static int pfkey_do_dump(struct pfkey_sock *pfk)
 280 {
 281         struct sadb_msg *hdr;
 282         int rc;
 283        
 284         rc = pfk-&gt;dump.dump(pfk);
 285         if (rc == -ENOBUFS)
 286                 return 0;
 287 
 288         if (pfk-&gt;dump.skb) {
 289                 if (!pfkey_can_dump(&amp;pfk-&gt;sk))  
 290                         return 0;
 291  
 292                 hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 293                 hdr-&gt;sadb_msg_seq = 0;
 294                 hdr-&gt;sadb_msg_errno = rc;
 295                 pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,
 296                                 &amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 297                 pfk-&gt;dump.skb = NULL;
 298         }
 299 
 300         pfkey_terminate_dump(pfk);
 301         return rc;
 302 }
</code></pre>

<p>相当于pfkey_dump_sa
<code>c
== 针对SA 每个sa调用
== == dump_sa
== == == pfkey_broadcast_one
== == == == skb_queue_tail(&amp;sk-&gt;sk_receive_queue, *skb2);
xfrm_state_walk(net, &amp;pfk-&gt;dump.u.state, dump_sa, (void *) pfk);
</code></p>

<pre><code>1554 int xfrm_state_walk(struct net *net, struct xfrm_state_walk *walk,
1555                     int (*func)(struct xfrm_state *, int, void*),
1556                     void *data)
1557 {
1558         struct xfrm_state *state;
1559         struct xfrm_state_walk *x;
1560         int err = 0;             
1561 
1562         if (walk-&gt;seq != 0 &amp;&amp; list_empty(&amp;walk-&gt;all))
1563                 return 0;
1564 
1565         spin_lock_bh(&amp;xfrm_state_lock);
1566         if (list_empty(&amp;walk-&gt;all)) &lt;=== 根据walk-&gt;all 判定是全新的遍历，还是接着上次的位置往后遍历
1567                 x = list_first_entry(&amp;net-&gt;xfrm.state_all, struct xfrm_state_walk, all);
1568         else
1569                 x = list_entry(&amp;walk-&gt;all, struct xfrm_state_walk, all);
1570         list_for_each_entry_from(x, &amp;net-&gt;xfrm.state_all, all) {
1571                 if (x-&gt;state == XFRM_STATE_DEAD)
1572                         continue;
1573                 state = container_of(x, struct xfrm_state, km);
1574                 if (!xfrm_id_proto_match(state-&gt;id.proto, walk-&gt;proto))
1575                         continue;
1576                 err = func(state, walk-&gt;seq, data); &lt;=== 根据fun的返回决定是继续遍历下一个SA还是停止
1577                 if (err) {
1578                         list_move_tail(&amp;walk-&gt;all, &amp;x-&gt;all);
1579                         goto out;
1580                 }
1581                 walk-&gt;seq++;
1582         }
1583         if (walk-&gt;seq == 0) {
1584                 err = -ENOENT;
1585                 goto out;
1586         }
1587         list_del_init(&amp;walk-&gt;all);
1588 out:
1589         spin_unlock_bh(&amp;xfrm_state_lock);
1590         return err;
1591 }
1592 EXPORT_SYMBOL(xfrm_state_walk);
</code></pre>

<ol>
<li>recvmsg
跟普通socket的recvmsg没有太大的区别。</li>
</ol>


<p>调用skb_recv_datagram从socket的sk_receive_queue队列里摘一个skb下来， 并将skb的数据copy到用户空间。</p>

<p>检查SA是否已经全部dump了。 如果还有没被dump的sa，并且socket的有比较宽裕的空间，则再次激活SA dump。
宽裕的剩余空间的检查，保证了dump的效率， 避免激活一次SA dump只能dump很少的SA。</p>

<pre><code class="c">3609 static int pfkey_recvmsg(struct kiocb *kiocb,
3610                          struct socket *sock, struct msghdr *msg, size_t len,
3611                          int flags)
3612 {
3613         struct sock *sk = sock-&gt;sk;
3614         struct pfkey_sock *pfk = pfkey_sk(sk);
3615         struct sk_buff *skb;
3616         int copied, err;
3617 
3618         err = -EINVAL;
3619         if (flags &amp; ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))
3620                 goto out;
3621 
3622         msg-&gt;msg_namelen = 0;
3623         skb = skb_recv_datagram(sk, flags, flags &amp; MSG_DONTWAIT, &amp;err);
3624         if (skb == NULL)
3625                 goto out;
3626 
3627         copied = skb-&gt;len;
3628         if (copied &gt; len) {
3629                 msg-&gt;msg_flags |= MSG_TRUNC;
3630                 copied = len;
3631         }
3632 
3633         skb_reset_transport_header(skb);
3634         err = skb_copy_datagram_iovec(skb, 0, msg-&gt;msg_iov, copied);
3635         if (err)
3636                 goto out_free;
3637 
3638         sock_recv_ts_and_drops(msg, sk, skb);
3639 
3640         err = (flags &amp; MSG_TRUNC) ? skb-&gt;len : copied;
3641 
3642         if (pfk-&gt;dump.dump != NULL &amp;&amp;
3643             3 * atomic_read(&amp;sk-&gt;sk_rmem_alloc) &lt;= sk-&gt;sk_rcvbuf)
3644                 pfkey_do_dump(pfk);
3645 
3646 out_free:
3647         skb_free_datagram(sk, skb);
3648 out:
3649         return err;
3650 }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pf_key Module Summary]]></title>
    <link href="http://martinbj2008.github.io/blog/2010/06/02/pfkey-in-kernel/"/>
    <updated>2010-06-02T00:00:00+08:00</updated>
    <id>http://martinbj2008.github.io/blog/2010/06/02/pfkey-in-kernel</id>
    <content type="html"><![CDATA[<h3>af_key.c</h3>

<p>linux kernel provide 3 method to manager SA/SP,
such as add/del/flush/dump SAs/SPs.
1. pf_key socket.
2. netlink message.
3. socket option.</p>

<p>The af_key.c implement the pf_key socket.</p>

<h3>part 1. pf_key socket defination about socket opertion.</h3>

<p>important function is
pfkey_create,pfkey_sendmsg,pfkey_recvmsg,
pfkey_release,datagram_poll,</p>

<pre><code class="c">static const struct proto_ops pfkey_ops = { 
.family        =    PF_KEY, 
.owner        =    THIS_MODULE, 
/* Operations that make no sense on pfkey sockets. */ 
.bind        =    sock_no_bind, 
.connect    =    sock_no_connect, 
.socketpair    =    sock_no_socketpair, 
.accept        =    sock_no_accept, 
.getname    =    sock_no_getname, 
.ioctl        =    sock_no_ioctl, 
.listen        =    sock_no_listen, 
.shutdown    =    sock_no_shutdown, 
.setsockopt    =    sock_no_setsockopt, 
.getsockopt    =    sock_no_getsockopt, 
.mmap        =    sock_no_mmap, 
.sendpage    =    sock_no_sendpage, 

/* Now the operations that really occur. */ 
.release    =    pfkey_release, 
.poll        =    datagram_poll, 
.sendmsg    =    pfkey_sendmsg, 
.recvmsg    =    pfkey_recvmsg, 
};


static struct net_proto_family pfkey_family_ops = { 
.family    =    PF_KEY, 
.create    =    pfkey_create, 
.owner    =    THIS_MODULE, 
};


struct pfkey_sock { 
/* struct sock must be the first member of struct pfkey_sock */ 
struct sock    sk; 
int        registered; 
int        promisc; 

struct { 
uint8_t        msg_version; 
uint32_t    msg_pid; 
int        (*dump)(struct pfkey_sock *sk); 
void        (*done)(struct pfkey_sock *sk); 
union { 
struct xfrm_policy_walk    policy; 
struct xfrm_state_walk    state; 
} u; 
struct sk_buff    *skb; 
} dump; 
}; 
</code></pre>

<h3>part 2. pf_key kernel message</h3>

<pre><code class="c">static struct xfrm_mgr pfkeyv2_mgr =
{ 
.id        = "pfkeyv2", 
.notify        = pfkey_send_notify, 
.acquire    = pfkey_send_acquire, 
.compile_policy    = pfkey_compile_policy, 
.new_mapping    = pfkey_send_new_mapping, 
.notify_policy    = pfkey_send_policy_notify, 
.migrate    = pfkey_send_migrate, 
};
</code></pre>

<h3>pf_key message process.</h3>

<p>in kernel 3.0, pf_key message format
A traditional TLV format.</p>

<p><code>header + (extenion-header + extention_value)*n</code></p>

<p>The header is sadb_msg.
extention header is sadb_ext.
extention value is different according the extention header.
Such as sadb_sa,sadb_x_policy and so on.</p>

<pre><code class="c">struct sadb_msg { 
uint8_t        sadb_msg_version; 
uint8_t        sadb_msg_type; 
uint8_t        sadb_msg_errno; 
uint8_t        sadb_msg_satype; 
uint16_t    sadb_msg_len; 
uint16_t    sadb_msg_reserved; 
uint32_t    sadb_msg_seq; 
uint32_t    sadb_msg_pid; 
} __attribute__((packed)); 
/* sizeof(struct sadb_msg) == 16 */ 

struct sadb_ext { 
uint16_t    sadb_ext_len; 
uint16_t    sadb_ext_type; 
} __attribute__((packed)); 
/* sizeof(struct sadb_ext) == 4 */ 


struct sadb_sa { 
uint16_t    sadb_sa_len; 
uint16_t    sadb_sa_exttype; 
__be32        sadb_sa_spi; 
uint8_t        sadb_sa_replay; 
uint8_t        sadb_sa_state; 
uint8_t        sadb_sa_auth; 
uint8_t        sadb_sa_encrypt; 
uint32_t    sadb_sa_flags; 
} __attribute__((packed)); 
/* sizeof(struct sadb_sa) == 16 */

struct sadb_x_policy { 
uint16_t    sadb_x_policy_len; 
uint16_t    sadb_x_policy_exttype; 
uint16_t    sadb_x_policy_type; 
uint8_t        sadb_x_policy_dir; 
uint8_t        sadb_x_policy_reserved; 
uint32_t    sadb_x_policy_id; 
uint32_t    sadb_x_policy_priority; 
} __attribute__((packed)); 
/* sizeof(struct sadb_x_policy) == 16 */
</code></pre>

<p>The application program(such as setkey) sent a command to kernel by sendmsg system API.
Thus in kernel pf_key will call pfkey_sendmsg.
pfkey_sendmsg will call pfkey_get_base_msg to do some simple check, and
then call pfkey_process.</p>

<p>pfkey_process will first pfkey_broadcast, then divid the extention message
to a pointer array one by one.
<code>void *ext_hdrs\[SADB_EXT_MAX\];</code>
<code>SADB_EXT_SA</code>         &mdash;->
<code>SADB_EXT_ADDRESS_SRC</code>&mdash;->
<code>SADB_EXT_ADDRESS_DST</code>&mdash;->
this pointer array will be used by the following handler.</p>

<p>and then call the pfkey_handler according the sadb_msg_type in the pf_key messag header.</p>

<p><code>typedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb, struct sadb_msg *hdr, void **ext_hdrs);</code></p>

<pre><code class="c">typedef int (*pfkey_handler)(struct sock *sk, struct sk_buff *skb, struct sadb_msg *hdr, void **ext_hdrs); 
static pfkey_handler pfkey_funcs[SADB_MAX + 1] = { 
[SADB_RESERVED]        = pfkey_reserved, 
[SADB_GETSPI]        = pfkey_getspi, 
[SADB_UPDATE]        = pfkey_add, 
[SADB_ADD]        = pfkey_add, 
[SADB_DELETE]        = pfkey_delete, 
[SADB_GET]        = pfkey_get, 
[SADB_ACQUIRE]        = pfkey_acquire, 
[SADB_REGISTER]        = pfkey_register, 
[SADB_EXPIRE]        = NULL, 
[SADB_FLUSH]        = pfkey_flush, 
[SADB_DUMP]        = pfkey_dump, 
[SADB_X_PROMISC]    = pfkey_promisc, 
[SADB_X_PCHANGE]    = NULL, 
[SADB_X_SPDUPDATE]    = pfkey_spdadd, 
[SADB_X_SPDADD]        = pfkey_spdadd, 
[SADB_X_SPDDELETE]    = pfkey_spddelete, 
[SADB_X_SPDGET]        = pfkey_spdget, 
[SADB_X_SPDACQUIRE]    = NULL, 
[SADB_X_SPDDUMP]    = pfkey_spddump, 
[SADB_X_SPDFLUSH]    = pfkey_spdflush, 
[SADB_X_SPDSETIDX]    = pfkey_spdadd, 
[SADB_X_SPDDELETE2]    = pfkey_spdget, 
[SADB_X_MIGRATE]    = pfkey_migrate, 
};
</code></pre>

<p>The policy related function was done in xfrm_policy.c and xfrm_state.c
3.1  policy add handler: pfkey_spdadd</p>

<p>3.2  polcy dump handler: pfkey_spddump
function pfkey_xfrm_policy2msg</p>

<p>3.3  policy flush handler: pfkey_spdflush.</p>

<p>3.4  SA add handler:pfkey_add</p>

<p>3.2  SA dump handler:pfkey_dump</p>

<p>3.3  SA flush handler:pfkey_flush</p>
]]></content>
  </entry>
  
</feed>
